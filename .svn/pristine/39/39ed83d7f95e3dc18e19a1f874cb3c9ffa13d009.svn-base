{"version":3,"names":[],"mappings":"","sources":["polymer/polymer.html"],"sourcesContent":["<!--\n@license\nCopyright (c) 2015 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n--><!--\n@license\nCopyright (c) 2014 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n--><link rel=\"import\" href=\"polymer-mini.html\">\n\n\n\n<script>Polymer.nar = [];\nPolymer.Annotations = {\nparseAnnotations: function (template) {\nvar list = [];\nvar content = template._content || template.content;\nthis._parseNodeAnnotations(content, list, template.hasAttribute('strip-whitespace'));\nreturn list;\n},\n_parseNodeAnnotations: function (node, list, stripWhiteSpace) {\nreturn node.nodeType === Node.TEXT_NODE ? this._parseTextNodeAnnotation(node, list) : this._parseElementAnnotations(node, list, stripWhiteSpace);\n},\n_bindingRegex: function () {\nvar IDENT = '(?:' + '[a-zA-Z_$][\\\\w.:$\\\\-*]*' + ')';\nvar NUMBER = '(?:' + '[-+]?[0-9]*\\\\.?[0-9]+(?:[eE][-+]?[0-9]+)?' + ')';\nvar SQUOTE_STRING = '(?:' + '\\'(?:[^\\'\\\\\\\\]|\\\\\\\\.)*\\'' + ')';\nvar DQUOTE_STRING = '(?:' + '\"(?:[^\"\\\\\\\\]|\\\\\\\\.)*\"' + ')';\nvar STRING = '(?:' + SQUOTE_STRING + '|' + DQUOTE_STRING + ')';\nvar ARGUMENT = '(?:' + IDENT + '|' + NUMBER + '|' + STRING + '\\\\s*' + ')';\nvar ARGUMENTS = '(?:' + ARGUMENT + '(?:,\\\\s*' + ARGUMENT + ')*' + ')';\nvar ARGUMENT_LIST = '(?:' + '\\\\(\\\\s*' + '(?:' + ARGUMENTS + '?' + ')' + '\\\\)\\\\s*' + ')';\nvar BINDING = '(' + IDENT + '\\\\s*' + ARGUMENT_LIST + '?' + ')';\nvar OPEN_BRACKET = '(\\\\[\\\\[|{{)' + '\\\\s*';\nvar CLOSE_BRACKET = '(?:]]|}})';\nvar NEGATE = '(?:(!)\\\\s*)?';\nvar EXPRESSION = OPEN_BRACKET + NEGATE + BINDING + CLOSE_BRACKET;\nreturn new RegExp(EXPRESSION, 'g');\n}(),\n_parseBindings: function (text) {\nvar re = this._bindingRegex;\nvar parts = [];\nvar lastIndex = 0;\nvar m;\nwhile ((m = re.exec(text)) !== null) {\nif (m.index > lastIndex) {\nparts.push({ literal: text.slice(lastIndex, m.index) });\n}\nvar mode = m[1][0];\nvar negate = Boolean(m[2]);\nvar value = m[3].trim();\nvar customEvent, notifyEvent, colon;\nif (mode == '{' && (colon = value.indexOf('::')) > 0) {\nnotifyEvent = value.substring(colon + 2);\nvalue = value.substring(0, colon);\ncustomEvent = true;\n}\nparts.push({\ncompoundIndex: parts.length,\nvalue: value,\nmode: mode,\nnegate: negate,\nevent: notifyEvent,\ncustomEvent: customEvent\n});\nlastIndex = re.lastIndex;\n}\nif (lastIndex && lastIndex < text.length) {\nvar literal = text.substring(lastIndex);\nif (literal) {\nparts.push({ literal: literal });\n}\n}\nif (parts.length) {\nreturn parts;\n}\n},\n_literalFromParts: function (parts) {\nvar s = '';\nfor (var i = 0; i < parts.length; i++) {\nvar literal = parts[i].literal;\ns += literal || '';\n}\nreturn s;\n},\n_parseTextNodeAnnotation: function (node, list) {\nvar parts = this._parseBindings(node.textContent);\nif (parts) {\nnode.textContent = this._literalFromParts(parts) || ' ';\nvar annote = {\nbindings: [{\nkind: 'text',\nname: 'textContent',\nparts: parts,\nisCompound: parts.length !== 1\n}]\n};\nlist.push(annote);\nreturn annote;\n}\n},\n_parseElementAnnotations: function (element, list, stripWhiteSpace) {\nvar annote = {\nbindings: [],\nevents: []\n};\nif (element.localName === 'content') {\nlist._hasContent = true;\n}\nthis._parseChildNodesAnnotations(element, annote, list, stripWhiteSpace);\nif (element.attributes) {\nthis._parseNodeAttributeAnnotations(element, annote, list);\nif (this.prepElement) {\nthis.prepElement(element);\n}\n}\nif (annote.bindings.length || annote.events.length || annote.id) {\nlist.push(annote);\n}\nreturn annote;\n},\n_parseChildNodesAnnotations: function (root, annote, list, stripWhiteSpace) {\nif (root.firstChild) {\nvar node = root.firstChild;\nvar i = 0;\nwhile (node) {\nvar next = node.nextSibling;\nif (node.localName === 'template' && !node.hasAttribute('preserve-content')) {\nthis._parseTemplate(node, i, list, annote);\n}\nif (node.nodeType === Node.TEXT_NODE) {\nvar n = next;\nwhile (n && n.nodeType === Node.TEXT_NODE) {\nnode.textContent += n.textContent;\nnext = n.nextSibling;\nroot.removeChild(n);\nn = next;\n}\nif (stripWhiteSpace && !node.textContent.trim()) {\nroot.removeChild(node);\ni--;\n}\n}\nif (node.parentNode) {\nvar childAnnotation = this._parseNodeAnnotations(node, list, stripWhiteSpace);\nif (childAnnotation) {\nchildAnnotation.parent = annote;\nchildAnnotation.index = i;\n}\n}\nnode = next;\ni++;\n}\n}\n},\n_parseTemplate: function (node, index, list, parent) {\nvar content = document.createDocumentFragment();\ncontent._notes = this.parseAnnotations(node);\ncontent.appendChild(node.content);\nlist.push({\nbindings: Polymer.nar,\nevents: Polymer.nar,\ntemplateContent: content,\nparent: parent,\nindex: index\n});\n},\n_parseNodeAttributeAnnotations: function (node, annotation) {\nvar attrs = Array.prototype.slice.call(node.attributes);\nfor (var i = attrs.length - 1, a; a = attrs[i]; i--) {\nvar n = a.name;\nvar v = a.value;\nvar b;\nif (n.slice(0, 3) === 'on-') {\nnode.removeAttribute(n);\nannotation.events.push({\nname: n.slice(3),\nvalue: v\n});\n} else if (b = this._parseNodeAttributeAnnotation(node, n, v)) {\nannotation.bindings.push(b);\n} else if (n === 'id') {\nannotation.id = v;\n}\n}\n},\n_parseNodeAttributeAnnotation: function (node, name, value) {\nvar parts = this._parseBindings(value);\nif (parts) {\nvar origName = name;\nvar kind = 'property';\nif (name[name.length - 1] == '$') {\nname = name.slice(0, -1);\nkind = 'attribute';\n}\nvar literal = this._literalFromParts(parts);\nif (literal && kind == 'attribute') {\nnode.setAttribute(name, literal);\n}\nif (node.localName === 'input' && origName === 'value') {\nnode.setAttribute(origName, '');\n}\nnode.removeAttribute(origName);\nvar propertyName = Polymer.CaseMap.dashToCamelCase(name);\nif (kind === 'property') {\nname = propertyName;\n}\nreturn {\nkind: kind,\nname: name,\npropertyName: propertyName,\nparts: parts,\nliteral: literal,\nisCompound: parts.length !== 1\n};\n}\n},\nfindAnnotatedNode: function (root, annote) {\nvar parent = annote.parent && Polymer.Annotations.findAnnotatedNode(root, annote.parent);\nif (parent) {\nfor (var n = parent.firstChild, i = 0; n; n = n.nextSibling) {\nif (annote.index === i++) {\nreturn n;\n}\n}\n} else {\nreturn root;\n}\n}\n};(function () {\nfunction resolveCss(cssText, ownerDocument) {\nreturn cssText.replace(CSS_URL_RX, function (m, pre, url, post) {\nreturn pre + '\\'' + resolve(url.replace(/[\"']/g, ''), ownerDocument) + '\\'' + post;\n});\n}\nfunction resolveAttrs(element, ownerDocument) {\nfor (var name in URL_ATTRS) {\nvar a$ = URL_ATTRS[name];\nfor (var i = 0, l = a$.length, a, at, v; i < l && (a = a$[i]); i++) {\nif (name === '*' || element.localName === name) {\nat = element.attributes[a];\nv = at && at.value;\nif (v && v.search(BINDING_RX) < 0) {\nat.value = a === 'style' ? resolveCss(v, ownerDocument) : resolve(v, ownerDocument);\n}\n}\n}\n}\n}\nfunction resolve(url, ownerDocument) {\nif (url && ABS_URL.test(url)) {\nreturn url;\n}\nvar resolver = getUrlResolver(ownerDocument);\nresolver.href = url;\nreturn resolver.href || url;\n}\nvar tempDoc;\nvar tempDocBase;\nfunction resolveUrl(url, baseUri) {\nif (!tempDoc) {\ntempDoc = document.implementation.createHTMLDocument('temp');\ntempDocBase = tempDoc.createElement('base');\ntempDoc.head.appendChild(tempDocBase);\n}\ntempDocBase.href = baseUri;\nreturn resolve(url, tempDoc);\n}\nfunction getUrlResolver(ownerDocument) {\nreturn ownerDocument.__urlResolver || (ownerDocument.__urlResolver = ownerDocument.createElement('a'));\n}\nvar CSS_URL_RX = /(url\\()([^)]*)(\\))/g;\nvar URL_ATTRS = {\n'*': [\n'href',\n'src',\n'style',\n'url'\n],\nform: ['action']\n};\nvar ABS_URL = /(^\\/)|(^#)|(^[\\w-\\d]*:)/;\nvar BINDING_RX = /\\{\\{|\\[\\[/;\nPolymer.ResolveUrl = {\nresolveCss: resolveCss,\nresolveAttrs: resolveAttrs,\nresolveUrl: resolveUrl\n};\n}());Polymer.Base._addFeature({\n_prepAnnotations: function () {\nif (!this._template) {\nthis._notes = [];\n} else {\nvar self = this;\nPolymer.Annotations.prepElement = function (element) {\nself._prepElement(element);\n};\nif (this._template._content && this._template._content._notes) {\nthis._notes = this._template._content._notes;\n} else {\nthis._notes = Polymer.Annotations.parseAnnotations(this._template);\nthis._processAnnotations(this._notes);\n}\nPolymer.Annotations.prepElement = null;\n}\n},\n_processAnnotations: function (notes) {\nfor (var i = 0; i < notes.length; i++) {\nvar note = notes[i];\nfor (var j = 0; j < note.bindings.length; j++) {\nvar b = note.bindings[j];\nfor (var k = 0; k < b.parts.length; k++) {\nvar p = b.parts[k];\nif (!p.literal) {\nvar signature = this._parseMethod(p.value);\nif (signature) {\np.signature = signature;\n} else {\np.model = this._modelForPath(p.value);\n}\n}\n}\n}\nif (note.templateContent) {\nthis._processAnnotations(note.templateContent._notes);\nvar pp = note.templateContent._parentProps = this._discoverTemplateParentProps(note.templateContent._notes);\nvar bindings = [];\nfor (var prop in pp) {\nvar name = '_parent_' + prop;\nbindings.push({\nindex: note.index,\nkind: 'property',\nname: name,\npropertyName: name,\nparts: [{\nmode: '{',\nmodel: prop,\nvalue: prop\n}]\n});\n}\nnote.bindings = note.bindings.concat(bindings);\n}\n}\n},\n_discoverTemplateParentProps: function (notes) {\nvar pp = {};\nfor (var i = 0, n; i < notes.length && (n = notes[i]); i++) {\nfor (var j = 0, b$ = n.bindings, b; j < b$.length && (b = b$[j]); j++) {\nfor (var k = 0, p$ = b.parts, p; k < p$.length && (p = p$[k]); k++) {\nif (p.signature) {\nvar args = p.signature.args;\nfor (var kk = 0; kk < args.length; kk++) {\nvar model = args[kk].model;\nif (model) {\npp[model] = true;\n}\n}\nif (p.signature.dynamicFn) {\npp[p.signature.method] = true;\n}\n} else {\nif (p.model) {\npp[p.model] = true;\n}\n}\n}\n}\nif (n.templateContent) {\nvar tpp = n.templateContent._parentProps;\nPolymer.Base.mixin(pp, tpp);\n}\n}\nreturn pp;\n},\n_prepElement: function (element) {\nPolymer.ResolveUrl.resolveAttrs(element, this._template.ownerDocument);\n},\n_findAnnotatedNode: Polymer.Annotations.findAnnotatedNode,\n_marshalAnnotationReferences: function () {\nif (this._template) {\nthis._marshalIdNodes();\nthis._marshalAnnotatedNodes();\nthis._marshalAnnotatedListeners();\n}\n},\n_configureAnnotationReferences: function () {\nvar notes = this._notes;\nvar nodes = this._nodes;\nfor (var i = 0; i < notes.length; i++) {\nvar note = notes[i];\nvar node = nodes[i];\nthis._configureTemplateContent(note, node);\nthis._configureCompoundBindings(note, node);\n}\n},\n_configureTemplateContent: function (note, node) {\nif (note.templateContent) {\nnode._content = note.templateContent;\n}\n},\n_configureCompoundBindings: function (note, node) {\nvar bindings = note.bindings;\nfor (var i = 0; i < bindings.length; i++) {\nvar binding = bindings[i];\nif (binding.isCompound) {\nvar storage = node.__compoundStorage__ || (node.__compoundStorage__ = {});\nvar parts = binding.parts;\nvar literals = new Array(parts.length);\nfor (var j = 0; j < parts.length; j++) {\nliterals[j] = parts[j].literal;\n}\nvar name = binding.name;\nstorage[name] = literals;\nif (binding.literal && binding.kind == 'property') {\nif (node._configValue) {\nnode._configValue(name, binding.literal);\n} else {\nnode[name] = binding.literal;\n}\n}\n}\n}\n},\n_marshalIdNodes: function () {\nthis.$ = {};\nfor (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {\nif (a.id) {\nthis.$[a.id] = this._findAnnotatedNode(this.root, a);\n}\n}\n},\n_marshalAnnotatedNodes: function () {\nif (this._notes && this._notes.length) {\nvar r = new Array(this._notes.length);\nfor (var i = 0; i < this._notes.length; i++) {\nr[i] = this._findAnnotatedNode(this.root, this._notes[i]);\n}\nthis._nodes = r;\n}\n},\n_marshalAnnotatedListeners: function () {\nfor (var i = 0, l = this._notes.length, a; i < l && (a = this._notes[i]); i++) {\nif (a.events && a.events.length) {\nvar node = this._findAnnotatedNode(this.root, a);\nfor (var j = 0, e$ = a.events, e; j < e$.length && (e = e$[j]); j++) {\nthis.listen(node, e.name, e.value);\n}\n}\n}\n}\n});Polymer.Base._addFeature({\nlisteners: {},\n_listenListeners: function (listeners) {\nvar node, name, eventName;\nfor (eventName in listeners) {\nif (eventName.indexOf('.') < 0) {\nnode = this;\nname = eventName;\n} else {\nname = eventName.split('.');\nnode = this.$[name[0]];\nname = name[1];\n}\nthis.listen(node, name, listeners[eventName]);\n}\n},\nlisten: function (node, eventName, methodName) {\nvar handler = this._recallEventHandler(this, eventName, node, methodName);\nif (!handler) {\nhandler = this._createEventHandler(node, eventName, methodName);\n}\nif (handler._listening) {\nreturn;\n}\nthis._listen(node, eventName, handler);\nhandler._listening = true;\n},\n_boundListenerKey: function (eventName, methodName) {\nreturn eventName + ':' + methodName;\n},\n_recordEventHandler: function (host, eventName, target, methodName, handler) {\nvar hbl = host.__boundListeners;\nif (!hbl) {\nhbl = host.__boundListeners = new WeakMap();\n}\nvar bl = hbl.get(target);\nif (!bl) {\nbl = {};\nhbl.set(target, bl);\n}\nvar key = this._boundListenerKey(eventName, methodName);\nbl[key] = handler;\n},\n_recallEventHandler: function (host, eventName, target, methodName) {\nvar hbl = host.__boundListeners;\nif (!hbl) {\nreturn;\n}\nvar bl = hbl.get(target);\nif (!bl) {\nreturn;\n}\nvar key = this._boundListenerKey(eventName, methodName);\nreturn bl[key];\n},\n_createEventHandler: function (node, eventName, methodName) {\nvar host = this;\nvar handler = function (e) {\nif (host[methodName]) {\nhost[methodName](e, e.detail);\n} else {\nhost._warn(host._logf('_createEventHandler', 'listener method `' + methodName + '` not defined'));\n}\n};\nhandler._listening = false;\nthis._recordEventHandler(host, eventName, node, methodName, handler);\nreturn handler;\n},\nunlisten: function (node, eventName, methodName) {\nvar handler = this._recallEventHandler(this, eventName, node, methodName);\nif (handler) {\nthis._unlisten(node, eventName, handler);\nhandler._listening = false;\n}\n},\n_listen: function (node, eventName, handler) {\nnode.addEventListener(eventName, handler);\n},\n_unlisten: function (node, eventName, handler) {\nnode.removeEventListener(eventName, handler);\n}\n});(function () {\n'use strict';\nvar wrap = Polymer.DomApi.wrap;\nvar HAS_NATIVE_TA = typeof document.head.style.touchAction === 'string';\nvar GESTURE_KEY = '__polymerGestures';\nvar HANDLED_OBJ = '__polymerGesturesHandled';\nvar TOUCH_ACTION = '__polymerGesturesTouchAction';\nvar TAP_DISTANCE = 25;\nvar TRACK_DISTANCE = 5;\nvar TRACK_LENGTH = 2;\nvar MOUSE_TIMEOUT = 2500;\nvar MOUSE_EVENTS = [\n'mousedown',\n'mousemove',\n'mouseup',\n'click'\n];\nvar MOUSE_WHICH_TO_BUTTONS = [\n0,\n1,\n4,\n2\n];\nvar MOUSE_HAS_BUTTONS = function () {\ntry {\nreturn new MouseEvent('test', { buttons: 1 }).buttons === 1;\n} catch (e) {\nreturn false;\n}\n}();\nvar IS_TOUCH_ONLY = navigator.userAgent.match(/iP(?:[oa]d|hone)|Android/);\nvar mouseCanceller = function (mouseEvent) {\nvar sc = mouseEvent.sourceCapabilities;\nif (sc && !sc.firesTouchEvents) {\nreturn;\n}\nmouseEvent[HANDLED_OBJ] = { skip: true };\nif (mouseEvent.type === 'click') {\nvar path = Polymer.dom(mouseEvent).path;\nfor (var i = 0; i < path.length; i++) {\nif (path[i] === POINTERSTATE.mouse.target) {\nreturn;\n}\n}\nmouseEvent.preventDefault();\nmouseEvent.stopPropagation();\n}\n};\nfunction setupTeardownMouseCanceller(setup) {\nfor (var i = 0, en; i < MOUSE_EVENTS.length; i++) {\nen = MOUSE_EVENTS[i];\nif (setup) {\ndocument.addEventListener(en, mouseCanceller, true);\n} else {\ndocument.removeEventListener(en, mouseCanceller, true);\n}\n}\n}\nfunction ignoreMouse() {\nif (IS_TOUCH_ONLY) {\nreturn;\n}\nif (!POINTERSTATE.mouse.mouseIgnoreJob) {\nsetupTeardownMouseCanceller(true);\n}\nvar unset = function () {\nsetupTeardownMouseCanceller();\nPOINTERSTATE.mouse.target = null;\nPOINTERSTATE.mouse.mouseIgnoreJob = null;\n};\nPOINTERSTATE.mouse.mouseIgnoreJob = Polymer.Debounce(POINTERSTATE.mouse.mouseIgnoreJob, unset, MOUSE_TIMEOUT);\n}\nfunction hasLeftMouseButton(ev) {\nvar type = ev.type;\nif (MOUSE_EVENTS.indexOf(type) === -1) {\nreturn false;\n}\nif (type === 'mousemove') {\nvar buttons = ev.buttons === undefined ? 1 : ev.buttons;\nif (ev instanceof window.MouseEvent && !MOUSE_HAS_BUTTONS) {\nbuttons = MOUSE_WHICH_TO_BUTTONS[ev.which] || 0;\n}\nreturn Boolean(buttons & 1);\n} else {\nvar button = ev.button === undefined ? 0 : ev.button;\nreturn button === 0;\n}\n}\nfunction isSyntheticClick(ev) {\nif (ev.type === 'click') {\nif (ev.detail === 0) {\nreturn true;\n}\nvar t = Gestures.findOriginalTarget(ev);\nvar bcr = t.getBoundingClientRect();\nvar x = ev.pageX, y = ev.pageY;\nreturn !(x >= bcr.left && x <= bcr.right && (y >= bcr.top && y <= bcr.bottom));\n}\nreturn false;\n}\nvar POINTERSTATE = {\nmouse: {\ntarget: null,\nmouseIgnoreJob: null\n},\ntouch: {\nx: 0,\ny: 0,\nid: -1,\nscrollDecided: false\n}\n};\nfunction firstTouchAction(ev) {\nvar path = Polymer.dom(ev).path;\nvar ta = 'auto';\nfor (var i = 0, n; i < path.length; i++) {\nn = path[i];\nif (n[TOUCH_ACTION]) {\nta = n[TOUCH_ACTION];\nbreak;\n}\n}\nreturn ta;\n}\nfunction trackDocument(stateObj, movefn, upfn) {\nstateObj.movefn = movefn;\nstateObj.upfn = upfn;\ndocument.addEventListener('mousemove', movefn);\ndocument.addEventListener('mouseup', upfn);\n}\nfunction untrackDocument(stateObj) {\ndocument.removeEventListener('mousemove', stateObj.movefn);\ndocument.removeEventListener('mouseup', stateObj.upfn);\nstateObj.movefn = null;\nstateObj.upfn = null;\n}\nvar Gestures = {\ngestures: {},\nrecognizers: [],\ndeepTargetFind: function (x, y) {\nvar node = document.elementFromPoint(x, y);\nvar next = node;\nwhile (next && next.shadowRoot) {\nnext = next.shadowRoot.elementFromPoint(x, y);\nif (next) {\nnode = next;\n}\n}\nreturn node;\n},\nfindOriginalTarget: function (ev) {\nif (ev.path) {\nreturn ev.path[0];\n}\nreturn ev.target;\n},\nhandleNative: function (ev) {\nvar handled;\nvar type = ev.type;\nvar node = wrap(ev.currentTarget);\nvar gobj = node[GESTURE_KEY];\nif (!gobj) {\nreturn;\n}\nvar gs = gobj[type];\nif (!gs) {\nreturn;\n}\nif (!ev[HANDLED_OBJ]) {\nev[HANDLED_OBJ] = {};\nif (type.slice(0, 5) === 'touch') {\nvar t = ev.changedTouches[0];\nif (type === 'touchstart') {\nif (ev.touches.length === 1) {\nPOINTERSTATE.touch.id = t.identifier;\n}\n}\nif (POINTERSTATE.touch.id !== t.identifier) {\nreturn;\n}\nif (!HAS_NATIVE_TA) {\nif (type === 'touchstart' || type === 'touchmove') {\nGestures.handleTouchAction(ev);\n}\n}\nif (type === 'touchend') {\nPOINTERSTATE.mouse.target = Polymer.dom(ev).rootTarget;\nignoreMouse();\n}\n}\n}\nhandled = ev[HANDLED_OBJ];\nif (handled.skip) {\nreturn;\n}\nvar recognizers = Gestures.recognizers;\nfor (var i = 0, r; i < recognizers.length; i++) {\nr = recognizers[i];\nif (gs[r.name] && !handled[r.name]) {\nif (r.flow && r.flow.start.indexOf(ev.type) > -1 && r.reset) {\nr.reset();\n}\n}\n}\nfor (i = 0, r; i < recognizers.length; i++) {\nr = recognizers[i];\nif (gs[r.name] && !handled[r.name]) {\nhandled[r.name] = true;\nr[type](ev);\n}\n}\n},\nhandleTouchAction: function (ev) {\nvar t = ev.changedTouches[0];\nvar type = ev.type;\nif (type === 'touchstart') {\nPOINTERSTATE.touch.x = t.clientX;\nPOINTERSTATE.touch.y = t.clientY;\nPOINTERSTATE.touch.scrollDecided = false;\n} else if (type === 'touchmove') {\nif (POINTERSTATE.touch.scrollDecided) {\nreturn;\n}\nPOINTERSTATE.touch.scrollDecided = true;\nvar ta = firstTouchAction(ev);\nvar prevent = false;\nvar dx = Math.abs(POINTERSTATE.touch.x - t.clientX);\nvar dy = Math.abs(POINTERSTATE.touch.y - t.clientY);\nif (!ev.cancelable) {\n} else if (ta === 'none') {\nprevent = true;\n} else if (ta === 'pan-x') {\nprevent = dy > dx;\n} else if (ta === 'pan-y') {\nprevent = dx > dy;\n}\nif (prevent) {\nev.preventDefault();\n} else {\nGestures.prevent('track');\n}\n}\n},\nadd: function (node, evType, handler) {\nnode = wrap(node);\nvar recognizer = this.gestures[evType];\nvar deps = recognizer.deps;\nvar name = recognizer.name;\nvar gobj = node[GESTURE_KEY];\nif (!gobj) {\nnode[GESTURE_KEY] = gobj = {};\n}\nfor (var i = 0, dep, gd; i < deps.length; i++) {\ndep = deps[i];\nif (IS_TOUCH_ONLY && MOUSE_EVENTS.indexOf(dep) > -1) {\ncontinue;\n}\ngd = gobj[dep];\nif (!gd) {\ngobj[dep] = gd = { _count: 0 };\n}\nif (gd._count === 0) {\nnode.addEventListener(dep, this.handleNative);\n}\ngd[name] = (gd[name] || 0) + 1;\ngd._count = (gd._count || 0) + 1;\n}\nnode.addEventListener(evType, handler);\nif (recognizer.touchAction) {\nthis.setTouchAction(node, recognizer.touchAction);\n}\n},\nremove: function (node, evType, handler) {\nnode = wrap(node);\nvar recognizer = this.gestures[evType];\nvar deps = recognizer.deps;\nvar name = recognizer.name;\nvar gobj = node[GESTURE_KEY];\nif (gobj) {\nfor (var i = 0, dep, gd; i < deps.length; i++) {\ndep = deps[i];\ngd = gobj[dep];\nif (gd && gd[name]) {\ngd[name] = (gd[name] || 1) - 1;\ngd._count = (gd._count || 1) - 1;\nif (gd._count === 0) {\nnode.removeEventListener(dep, this.handleNative);\n}\n}\n}\n}\nnode.removeEventListener(evType, handler);\n},\nregister: function (recog) {\nthis.recognizers.push(recog);\nfor (var i = 0; i < recog.emits.length; i++) {\nthis.gestures[recog.emits[i]] = recog;\n}\n},\nfindRecognizerByEvent: function (evName) {\nfor (var i = 0, r; i < this.recognizers.length; i++) {\nr = this.recognizers[i];\nfor (var j = 0, n; j < r.emits.length; j++) {\nn = r.emits[j];\nif (n === evName) {\nreturn r;\n}\n}\n}\nreturn null;\n},\nsetTouchAction: function (node, value) {\nif (HAS_NATIVE_TA) {\nnode.style.touchAction = value;\n}\nnode[TOUCH_ACTION] = value;\n},\nfire: function (target, type, detail) {\nvar ev = Polymer.Base.fire(type, detail, {\nnode: target,\nbubbles: true,\ncancelable: true\n});\nif (ev.defaultPrevented) {\nvar preventer = detail.preventer || detail.sourceEvent;\nif (preventer && preventer.preventDefault) {\npreventer.preventDefault();\n}\n}\n},\nprevent: function (evName) {\nvar recognizer = this.findRecognizerByEvent(evName);\nif (recognizer.info) {\nrecognizer.info.prevent = true;\n}\n},\nresetMouseCanceller: function () {\nif (POINTERSTATE.mouse.mouseIgnoreJob) {\nPOINTERSTATE.mouse.mouseIgnoreJob.complete();\n}\n}\n};\nGestures.register({\nname: 'downup',\ndeps: [\n'mousedown',\n'touchstart',\n'touchend'\n],\nflow: {\nstart: [\n'mousedown',\n'touchstart'\n],\nend: [\n'mouseup',\n'touchend'\n]\n},\nemits: [\n'down',\n'up'\n],\ninfo: {\nmovefn: null,\nupfn: null\n},\nreset: function () {\nuntrackDocument(this.info);\n},\nmousedown: function (e) {\nif (!hasLeftMouseButton(e)) {\nreturn;\n}\nvar t = Gestures.findOriginalTarget(e);\nvar self = this;\nvar movefn = function movefn(e) {\nif (!hasLeftMouseButton(e)) {\nself.fire('up', t, e);\nuntrackDocument(self.info);\n}\n};\nvar upfn = function upfn(e) {\nif (hasLeftMouseButton(e)) {\nself.fire('up', t, e);\n}\nuntrackDocument(self.info);\n};\ntrackDocument(this.info, movefn, upfn);\nthis.fire('down', t, e);\n},\ntouchstart: function (e) {\nthis.fire('down', Gestures.findOriginalTarget(e), e.changedTouches[0], e);\n},\ntouchend: function (e) {\nthis.fire('up', Gestures.findOriginalTarget(e), e.changedTouches[0], e);\n},\nfire: function (type, target, event, preventer) {\nGestures.fire(target, type, {\nx: event.clientX,\ny: event.clientY,\nsourceEvent: event,\npreventer: preventer,\nprevent: function (e) {\nreturn Gestures.prevent(e);\n}\n});\n}\n});\nGestures.register({\nname: 'track',\ntouchAction: 'none',\ndeps: [\n'mousedown',\n'touchstart',\n'touchmove',\n'touchend'\n],\nflow: {\nstart: [\n'mousedown',\n'touchstart'\n],\nend: [\n'mouseup',\n'touchend'\n]\n},\nemits: ['track'],\ninfo: {\nx: 0,\ny: 0,\nstate: 'start',\nstarted: false,\nmoves: [],\naddMove: function (move) {\nif (this.moves.length > TRACK_LENGTH) {\nthis.moves.shift();\n}\nthis.moves.push(move);\n},\nmovefn: null,\nupfn: null,\nprevent: false\n},\nreset: function () {\nthis.info.state = 'start';\nthis.info.started = false;\nthis.info.moves = [];\nthis.info.x = 0;\nthis.info.y = 0;\nthis.info.prevent = false;\nuntrackDocument(this.info);\n},\nhasMovedEnough: function (x, y) {\nif (this.info.prevent) {\nreturn false;\n}\nif (this.info.started) {\nreturn true;\n}\nvar dx = Math.abs(this.info.x - x);\nvar dy = Math.abs(this.info.y - y);\nreturn dx >= TRACK_DISTANCE || dy >= TRACK_DISTANCE;\n},\nmousedown: function (e) {\nif (!hasLeftMouseButton(e)) {\nreturn;\n}\nvar t = Gestures.findOriginalTarget(e);\nvar self = this;\nvar movefn = function movefn(e) {\nvar x = e.clientX, y = e.clientY;\nif (self.hasMovedEnough(x, y)) {\nself.info.state = self.info.started ? e.type === 'mouseup' ? 'end' : 'track' : 'start';\nif (self.info.state === 'start') {\nGestures.prevent('tap');\n}\nself.info.addMove({\nx: x,\ny: y\n});\nif (!hasLeftMouseButton(e)) {\nself.info.state = 'end';\nuntrackDocument(self.info);\n}\nself.fire(t, e);\nself.info.started = true;\n}\n};\nvar upfn = function upfn(e) {\nif (self.info.started) {\nmovefn(e);\n}\nuntrackDocument(self.info);\n};\ntrackDocument(this.info, movefn, upfn);\nthis.info.x = e.clientX;\nthis.info.y = e.clientY;\n},\ntouchstart: function (e) {\nvar ct = e.changedTouches[0];\nthis.info.x = ct.clientX;\nthis.info.y = ct.clientY;\n},\ntouchmove: function (e) {\nvar t = Gestures.findOriginalTarget(e);\nvar ct = e.changedTouches[0];\nvar x = ct.clientX, y = ct.clientY;\nif (this.hasMovedEnough(x, y)) {\nif (this.info.state === 'start') {\nGestures.prevent('tap');\n}\nthis.info.addMove({\nx: x,\ny: y\n});\nthis.fire(t, ct);\nthis.info.state = 'track';\nthis.info.started = true;\n}\n},\ntouchend: function (e) {\nvar t = Gestures.findOriginalTarget(e);\nvar ct = e.changedTouches[0];\nif (this.info.started) {\nthis.info.state = 'end';\nthis.info.addMove({\nx: ct.clientX,\ny: ct.clientY\n});\nthis.fire(t, ct, e);\n}\n},\nfire: function (target, touch, preventer) {\nvar secondlast = this.info.moves[this.info.moves.length - 2];\nvar lastmove = this.info.moves[this.info.moves.length - 1];\nvar dx = lastmove.x - this.info.x;\nvar dy = lastmove.y - this.info.y;\nvar ddx, ddy = 0;\nif (secondlast) {\nddx = lastmove.x - secondlast.x;\nddy = lastmove.y - secondlast.y;\n}\nreturn Gestures.fire(target, 'track', {\nstate: this.info.state,\nx: touch.clientX,\ny: touch.clientY,\ndx: dx,\ndy: dy,\nddx: ddx,\nddy: ddy,\nsourceEvent: touch,\npreventer: preventer,\nhover: function () {\nreturn Gestures.deepTargetFind(touch.clientX, touch.clientY);\n}\n});\n}\n});\nGestures.register({\nname: 'tap',\ndeps: [\n'mousedown',\n'click',\n'touchstart',\n'touchend'\n],\nflow: {\nstart: [\n'mousedown',\n'touchstart'\n],\nend: [\n'click',\n'touchend'\n]\n},\nemits: ['tap'],\ninfo: {\nx: NaN,\ny: NaN,\nprevent: false\n},\nreset: function () {\nthis.info.x = NaN;\nthis.info.y = NaN;\nthis.info.prevent = false;\n},\nsave: function (e) {\nthis.info.x = e.clientX;\nthis.info.y = e.clientY;\n},\nmousedown: function (e) {\nif (hasLeftMouseButton(e)) {\nthis.save(e);\n}\n},\nclick: function (e) {\nif (hasLeftMouseButton(e)) {\nthis.forward(e);\n}\n},\ntouchstart: function (e) {\nthis.save(e.changedTouches[0], e);\n},\ntouchend: function (e) {\nthis.forward(e.changedTouches[0], e);\n},\nforward: function (e, preventer) {\nvar dx = Math.abs(e.clientX - this.info.x);\nvar dy = Math.abs(e.clientY - this.info.y);\nvar t = Gestures.findOriginalTarget(e);\nif (isNaN(dx) || isNaN(dy) || dx <= TAP_DISTANCE && dy <= TAP_DISTANCE || isSyntheticClick(e)) {\nif (!this.info.prevent) {\nGestures.fire(t, 'tap', {\nx: e.clientX,\ny: e.clientY,\nsourceEvent: e,\npreventer: preventer\n});\n}\n}\n}\n});\nvar DIRECTION_MAP = {\nx: 'pan-x',\ny: 'pan-y',\nnone: 'none',\nall: 'auto'\n};\nPolymer.Base._addFeature({\n_setupGestures: function () {\nthis.__polymerGestures = null;\n},\n_listen: function (node, eventName, handler) {\nif (Gestures.gestures[eventName]) {\nGestures.add(node, eventName, handler);\n} else {\nnode.addEventListener(eventName, handler);\n}\n},\n_unlisten: function (node, eventName, handler) {\nif (Gestures.gestures[eventName]) {\nGestures.remove(node, eventName, handler);\n} else {\nnode.removeEventListener(eventName, handler);\n}\n},\nsetScrollDirection: function (direction, node) {\nnode = node || this;\nGestures.setTouchAction(node, DIRECTION_MAP[direction] || 'auto');\n}\n});\nPolymer.Gestures = Gestures;\n}());(function () {\n'use strict';\nPolymer.Base._addFeature({\n$$: function (slctr) {\nreturn Polymer.dom(this.root).querySelector(slctr);\n},\ntoggleClass: function (name, bool, node) {\nnode = node || this;\nif (arguments.length == 1) {\nbool = !node.classList.contains(name);\n}\nif (bool) {\nPolymer.dom(node).classList.add(name);\n} else {\nPolymer.dom(node).classList.remove(name);\n}\n},\ntoggleAttribute: function (name, bool, node) {\nnode = node || this;\nif (arguments.length == 1) {\nbool = !node.hasAttribute(name);\n}\nif (bool) {\nPolymer.dom(node).setAttribute(name, '');\n} else {\nPolymer.dom(node).removeAttribute(name);\n}\n},\nclassFollows: function (name, toElement, fromElement) {\nif (fromElement) {\nPolymer.dom(fromElement).classList.remove(name);\n}\nif (toElement) {\nPolymer.dom(toElement).classList.add(name);\n}\n},\nattributeFollows: function (name, toElement, fromElement) {\nif (fromElement) {\nPolymer.dom(fromElement).removeAttribute(name);\n}\nif (toElement) {\nPolymer.dom(toElement).setAttribute(name, '');\n}\n},\ngetEffectiveChildNodes: function () {\nreturn Polymer.dom(this).getEffectiveChildNodes();\n},\ngetEffectiveChildren: function () {\nvar list = Polymer.dom(this).getEffectiveChildNodes();\nreturn list.filter(function (n) {\nreturn n.nodeType === Node.ELEMENT_NODE;\n});\n},\ngetEffectiveTextContent: function () {\nvar cn = this.getEffectiveChildNodes();\nvar tc = [];\nfor (var i = 0, c; c = cn[i]; i++) {\nif (c.nodeType !== Node.COMMENT_NODE) {\ntc.push(Polymer.dom(c).textContent);\n}\n}\nreturn tc.join('');\n},\nqueryEffectiveChildren: function (slctr) {\nvar e$ = Polymer.dom(this).queryDistributedElements(slctr);\nreturn e$ && e$[0];\n},\nqueryAllEffectiveChildren: function (slctr) {\nreturn Polymer.dom(this).queryDistributedElements(slctr);\n},\ngetContentChildNodes: function (slctr) {\nvar content = Polymer.dom(this.root).querySelector(slctr || 'content');\nreturn content ? Polymer.dom(content).getDistributedNodes() : [];\n},\ngetContentChildren: function (slctr) {\nreturn this.getContentChildNodes(slctr).filter(function (n) {\nreturn n.nodeType === Node.ELEMENT_NODE;\n});\n},\nfire: function (type, detail, options) {\noptions = options || Polymer.nob;\nvar node = options.node || this;\ndetail = detail === null || detail === undefined ? {} : detail;\nvar bubbles = options.bubbles === undefined ? true : options.bubbles;\nvar cancelable = Boolean(options.cancelable);\nvar useCache = options._useCache;\nvar event = this._getEvent(type, bubbles, cancelable, useCache);\nevent.detail = detail;\nif (useCache) {\nthis.__eventCache[type] = null;\n}\nnode.dispatchEvent(event);\nif (useCache) {\nthis.__eventCache[type] = event;\n}\nreturn event;\n},\n__eventCache: {},\n_getEvent: function (type, bubbles, cancelable, useCache) {\nvar event = useCache && this.__eventCache[type];\nif (!event || (event.bubbles != bubbles || event.cancelable != cancelable)) {\nevent = new Event(type, {\nbubbles: Boolean(bubbles),\ncancelable: cancelable\n});\n}\nreturn event;\n},\nasync: function (callback, waitTime) {\nvar self = this;\nreturn Polymer.Async.run(function () {\ncallback.call(self);\n}, waitTime);\n},\ncancelAsync: function (handle) {\nPolymer.Async.cancel(handle);\n},\narrayDelete: function (path, item) {\nvar index;\nif (Array.isArray(path)) {\nindex = path.indexOf(item);\nif (index >= 0) {\nreturn path.splice(index, 1);\n}\n} else {\nvar arr = this._get(path);\nindex = arr.indexOf(item);\nif (index >= 0) {\nreturn this.splice(path, index, 1);\n}\n}\n},\ntransform: function (transform, node) {\nnode = node || this;\nnode.style.webkitTransform = transform;\nnode.style.transform = transform;\n},\ntranslate3d: function (x, y, z, node) {\nnode = node || this;\nthis.transform('translate3d(' + x + ',' + y + ',' + z + ')', node);\n},\nimportHref: function (href, onload, onerror, optAsync) {\nvar link = document.createElement('link');\nlink.rel = 'import';\nlink.href = href;\nvar list = Polymer.Base.importHref.imported = Polymer.Base.importHref.imported || {};\nvar cached = list[link.href];\nvar imprt = cached || link;\nvar self = this;\nif (onload) {\nvar loadListener = function (e) {\ne.target.__firedLoad = true;\ne.target.removeEventListener('load', loadListener);\nreturn onload.call(self, e);\n};\nimprt.addEventListener('load', loadListener);\n}\nif (onerror) {\nvar errorListener = function (e) {\ne.target.__firedError = true;\ne.target.removeEventListener('error', errorListener);\nreturn onerror.call(self, e);\n};\nimprt.addEventListener('error', errorListener);\n}\nif (cached) {\nif (cached.__firedLoad) {\ncached.dispatchEvent(new Event('load'));\n}\nif (cached.__firedError) {\ncached.dispatchEvent(new Event('error'));\n}\n} else {\nlist[link.href] = link;\noptAsync = Boolean(optAsync);\nif (optAsync) {\nlink.setAttribute('async', '');\n}\ndocument.head.appendChild(link);\n}\nreturn imprt;\n},\ncreate: function (tag, props) {\nvar elt = document.createElement(tag);\nif (props) {\nfor (var n in props) {\nelt[n] = props[n];\n}\n}\nreturn elt;\n},\nisLightDescendant: function (node) {\nreturn this !== node && this.contains(node) && Polymer.dom(this).getOwnerRoot() === Polymer.dom(node).getOwnerRoot();\n},\nisLocalDescendant: function (node) {\nreturn this.root === Polymer.dom(node).getOwnerRoot();\n}\n});\nif (!Polymer.Settings.useNativeCustomElements) {\nvar importHref = Polymer.Base.importHref;\nPolymer.Base.importHref = function (href, onload, onerror, optAsync) {\nCustomElements.ready = false;\nvar loadFn = function (e) {\nCustomElements.upgradeDocumentTree(document);\nCustomElements.ready = true;\nif (onload) {\nreturn onload.call(this, e);\n}\n};\nreturn importHref.call(this, href, loadFn, onerror, optAsync);\n};\n}\n}());Polymer.Bind = {\nprepareModel: function (model) {\nPolymer.Base.mixin(model, this._modelApi);\n},\n_modelApi: {\n_notifyChange: function (source, event, value) {\nvalue = value === undefined ? this[source] : value;\nevent = event || Polymer.CaseMap.camelToDashCase(source) + '-changed';\nthis.fire(event, { value: value }, {\nbubbles: false,\ncancelable: false,\n_useCache: true\n});\n},\n_propertySetter: function (property, value, effects, fromAbove) {\nvar old = this.__data__[property];\nif (old !== value && (old === old || value === value)) {\nthis.__data__[property] = value;\nif (typeof value == 'object') {\nthis._clearPath(property);\n}\nif (this._propertyChanged) {\nthis._propertyChanged(property, value, old);\n}\nif (effects) {\nthis._effectEffects(property, value, effects, old, fromAbove);\n}\n}\nreturn old;\n},\n__setProperty: function (property, value, quiet, node) {\nnode = node || this;\nvar effects = node._propertyEffects && node._propertyEffects[property];\nif (effects) {\nnode._propertySetter(property, value, effects, quiet);\n} else if (node[property] !== value) {\nnode[property] = value;\n}\n},\n_effectEffects: function (property, value, effects, old, fromAbove) {\nfor (var i = 0, l = effects.length, fx; i < l && (fx = effects[i]); i++) {\nfx.fn.call(this, property, this[property], fx.effect, old, fromAbove);\n}\n},\n_clearPath: function (path) {\nfor (var prop in this.__data__) {\nif (prop.indexOf(path + '.') === 0) {\nthis.__data__[prop] = undefined;\n}\n}\n}\n},\nensurePropertyEffects: function (model, property) {\nif (!model._propertyEffects) {\nmodel._propertyEffects = {};\n}\nvar fx = model._propertyEffects[property];\nif (!fx) {\nfx = model._propertyEffects[property] = [];\n}\nreturn fx;\n},\naddPropertyEffect: function (model, property, kind, effect) {\nvar fx = this.ensurePropertyEffects(model, property);\nvar propEffect = {\nkind: kind,\neffect: effect,\nfn: Polymer.Bind['_' + kind + 'Effect']\n};\nfx.push(propEffect);\nreturn propEffect;\n},\ncreateBindings: function (model) {\nvar fx$ = model._propertyEffects;\nif (fx$) {\nfor (var n in fx$) {\nvar fx = fx$[n];\nfx.sort(this._sortPropertyEffects);\nthis._createAccessors(model, n, fx);\n}\n}\n},\n_sortPropertyEffects: function () {\nvar EFFECT_ORDER = {\n'compute': 0,\n'annotation': 1,\n'annotatedComputation': 2,\n'reflect': 3,\n'notify': 4,\n'observer': 5,\n'complexObserver': 6,\n'function': 7\n};\nreturn function (a, b) {\nreturn EFFECT_ORDER[a.kind] - EFFECT_ORDER[b.kind];\n};\n}(),\n_createAccessors: function (model, property, effects) {\nvar defun = {\nget: function () {\nreturn this.__data__[property];\n}\n};\nvar setter = function (value) {\nthis._propertySetter(property, value, effects);\n};\nvar info = model.getPropertyInfo && model.getPropertyInfo(property);\nif (info && info.readOnly) {\nif (!info.computed) {\nmodel['_set' + this.upper(property)] = setter;\n}\n} else {\ndefun.set = setter;\n}\nObject.defineProperty(model, property, defun);\n},\nupper: function (name) {\nreturn name[0].toUpperCase() + name.substring(1);\n},\n_addAnnotatedListener: function (model, index, property, path, event, negated) {\nif (!model._bindListeners) {\nmodel._bindListeners = [];\n}\nvar fn = this._notedListenerFactory(property, path, this._isStructured(path), negated);\nvar eventName = event || Polymer.CaseMap.camelToDashCase(property) + '-changed';\nmodel._bindListeners.push({\nindex: index,\nproperty: property,\npath: path,\nchangedFn: fn,\nevent: eventName\n});\n},\n_isStructured: function (path) {\nreturn path.indexOf('.') > 0;\n},\n_isEventBogus: function (e, target) {\nreturn e.path && e.path[0] !== target;\n},\n_notedListenerFactory: function (property, path, isStructured, negated) {\nreturn function (target, value, targetPath) {\nif (targetPath) {\nthis._notifyPath(this._fixPath(path, property, targetPath), value);\n} else {\nvalue = target[property];\nif (negated) {\nvalue = !value;\n}\nif (!isStructured) {\nthis[path] = value;\n} else {\nif (this.__data__[path] != value) {\nthis.set(path, value);\n}\n}\n}\n};\n},\nprepareInstance: function (inst) {\ninst.__data__ = Object.create(null);\n},\nsetupBindListeners: function (inst) {\nvar b$ = inst._bindListeners;\nfor (var i = 0, l = b$.length, info; i < l && (info = b$[i]); i++) {\nvar node = inst._nodes[info.index];\nthis._addNotifyListener(node, inst, info.event, info.changedFn);\n}\n},\n_addNotifyListener: function (element, context, event, changedFn) {\nelement.addEventListener(event, function (e) {\nreturn context._notifyListener(changedFn, e);\n});\n}\n};Polymer.Base.extend(Polymer.Bind, {\n_shouldAddListener: function (effect) {\nreturn effect.name && effect.kind != 'attribute' && effect.kind != 'text' && !effect.isCompound && effect.parts[0].mode === '{';\n},\n_annotationEffect: function (source, value, effect) {\nif (source != effect.value) {\nvalue = this._get(effect.value);\nthis.__data__[effect.value] = value;\n}\nthis._applyEffectValue(effect, value);\n},\n_reflectEffect: function (source, value, effect) {\nthis.reflectPropertyToAttribute(source, effect.attribute, value);\n},\n_notifyEffect: function (source, value, effect, old, fromAbove) {\nif (!fromAbove) {\nthis._notifyChange(source, effect.event, value);\n}\n},\n_functionEffect: function (source, value, fn, old, fromAbove) {\nfn.call(this, source, value, old, fromAbove);\n},\n_observerEffect: function (source, value, effect, old) {\nvar fn = this[effect.method];\nif (fn) {\nfn.call(this, value, old);\n} else {\nthis._warn(this._logf('_observerEffect', 'observer method `' + effect.method + '` not defined'));\n}\n},\n_complexObserverEffect: function (source, value, effect) {\nvar fn = this[effect.method];\nif (fn) {\nvar args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);\nif (args) {\nfn.apply(this, args);\n}\n} else if (effect.dynamicFn) {\n} else {\nthis._warn(this._logf('_complexObserverEffect', 'observer method `' + effect.method + '` not defined'));\n}\n},\n_computeEffect: function (source, value, effect) {\nvar fn = this[effect.method];\nif (fn) {\nvar args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);\nif (args) {\nvar computedvalue = fn.apply(this, args);\nthis.__setProperty(effect.name, computedvalue);\n}\n} else if (effect.dynamicFn) {\n} else {\nthis._warn(this._logf('_computeEffect', 'compute method `' + effect.method + '` not defined'));\n}\n},\n_annotatedComputationEffect: function (source, value, effect) {\nvar computedHost = this._rootDataHost || this;\nvar fn = computedHost[effect.method];\nif (fn) {\nvar args = Polymer.Bind._marshalArgs(this.__data__, effect, source, value);\nif (args) {\nvar computedvalue = fn.apply(computedHost, args);\nthis._applyEffectValue(effect, computedvalue);\n}\n} else if (effect.dynamicFn) {\n} else {\ncomputedHost._warn(computedHost._logf('_annotatedComputationEffect', 'compute method `' + effect.method + '` not defined'));\n}\n},\n_marshalArgs: function (model, effect, path, value) {\nvar values = [];\nvar args = effect.args;\nvar bailoutEarly = args.length > 1 || effect.dynamicFn;\nfor (var i = 0, l = args.length; i < l; i++) {\nvar arg = args[i];\nvar name = arg.name;\nvar v;\nif (arg.literal) {\nv = arg.value;\n} else if (path === name) {\nv = value;\n} else {\nv = model[name];\nif (v === undefined && arg.structured) {\nv = Polymer.Base._get(name, model);\n}\n}\nif (bailoutEarly && v === undefined) {\nreturn;\n}\nif (arg.wildcard) {\nvar matches = path.indexOf(name + '.') === 0;\nvalues[i] = {\npath: matches ? path : name,\nvalue: matches ? value : v,\nbase: v\n};\n} else {\nvalues[i] = v;\n}\n}\nreturn values;\n}\n});Polymer.Base._addFeature({\n_addPropertyEffect: function (property, kind, effect) {\nvar prop = Polymer.Bind.addPropertyEffect(this, property, kind, effect);\nprop.pathFn = this['_' + prop.kind + 'PathEffect'];\n},\n_prepEffects: function () {\nPolymer.Bind.prepareModel(this);\nthis._addAnnotationEffects(this._notes);\n},\n_prepBindings: function () {\nPolymer.Bind.createBindings(this);\n},\n_addPropertyEffects: function (properties) {\nif (properties) {\nfor (var p in properties) {\nvar prop = properties[p];\nif (prop.observer) {\nthis._addObserverEffect(p, prop.observer);\n}\nif (prop.computed) {\nprop.readOnly = true;\nthis._addComputedEffect(p, prop.computed);\n}\nif (prop.notify) {\nthis._addPropertyEffect(p, 'notify', { event: Polymer.CaseMap.camelToDashCase(p) + '-changed' });\n}\nif (prop.reflectToAttribute) {\nvar attr = Polymer.CaseMap.camelToDashCase(p);\nif (attr[0] === '-') {\nthis._warn(this._logf('_addPropertyEffects', 'Property ' + p + ' cannot be reflected to attribute ' + attr + ' because \"-\" is not a valid starting attribute name. Use a lowercase first letter for the property instead.'));\n} else {\nthis._addPropertyEffect(p, 'reflect', { attribute: attr });\n}\n}\nif (prop.readOnly) {\nPolymer.Bind.ensurePropertyEffects(this, p);\n}\n}\n}\n},\n_addComputedEffect: function (name, expression) {\nvar sig = this._parseMethod(expression);\nvar dynamicFn = sig.dynamicFn;\nfor (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\nthis._addPropertyEffect(arg.model, 'compute', {\nmethod: sig.method,\nargs: sig.args,\ntrigger: arg,\nname: name,\ndynamicFn: dynamicFn\n});\n}\nif (dynamicFn) {\nthis._addPropertyEffect(sig.method, 'compute', {\nmethod: sig.method,\nargs: sig.args,\ntrigger: null,\nname: name,\ndynamicFn: dynamicFn\n});\n}\n},\n_addObserverEffect: function (property, observer) {\nthis._addPropertyEffect(property, 'observer', {\nmethod: observer,\nproperty: property\n});\n},\n_addComplexObserverEffects: function (observers) {\nif (observers) {\nfor (var i = 0, o; i < observers.length && (o = observers[i]); i++) {\nthis._addComplexObserverEffect(o);\n}\n}\n},\n_addComplexObserverEffect: function (observer) {\nvar sig = this._parseMethod(observer);\nif (!sig) {\nthrow new Error('Malformed observer expression \\'' + observer + '\\'');\n}\nvar dynamicFn = sig.dynamicFn;\nfor (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\nthis._addPropertyEffect(arg.model, 'complexObserver', {\nmethod: sig.method,\nargs: sig.args,\ntrigger: arg,\ndynamicFn: dynamicFn\n});\n}\nif (dynamicFn) {\nthis._addPropertyEffect(sig.method, 'complexObserver', {\nmethod: sig.method,\nargs: sig.args,\ntrigger: null,\ndynamicFn: dynamicFn\n});\n}\n},\n_addAnnotationEffects: function (notes) {\nfor (var i = 0, note; i < notes.length && (note = notes[i]); i++) {\nvar b$ = note.bindings;\nfor (var j = 0, binding; j < b$.length && (binding = b$[j]); j++) {\nthis._addAnnotationEffect(binding, i);\n}\n}\n},\n_addAnnotationEffect: function (note, index) {\nif (Polymer.Bind._shouldAddListener(note)) {\nPolymer.Bind._addAnnotatedListener(this, index, note.name, note.parts[0].value, note.parts[0].event, note.parts[0].negate);\n}\nfor (var i = 0; i < note.parts.length; i++) {\nvar part = note.parts[i];\nif (part.signature) {\nthis._addAnnotatedComputationEffect(note, part, index);\n} else if (!part.literal) {\nif (note.kind === 'attribute' && note.name[0] === '-') {\nthis._warn(this._logf('_addAnnotationEffect', 'Cannot set attribute ' + note.name + ' because \"-\" is not a valid attribute starting character'));\n} else {\nthis._addPropertyEffect(part.model, 'annotation', {\nkind: note.kind,\nindex: index,\nname: note.name,\npropertyName: note.propertyName,\nvalue: part.value,\nisCompound: note.isCompound,\ncompoundIndex: part.compoundIndex,\nevent: part.event,\ncustomEvent: part.customEvent,\nnegate: part.negate\n});\n}\n}\n}\n},\n_addAnnotatedComputationEffect: function (note, part, index) {\nvar sig = part.signature;\nif (sig.static) {\nthis.__addAnnotatedComputationEffect('__static__', index, note, part, null);\n} else {\nfor (var i = 0, arg; i < sig.args.length && (arg = sig.args[i]); i++) {\nif (!arg.literal) {\nthis.__addAnnotatedComputationEffect(arg.model, index, note, part, arg);\n}\n}\nif (sig.dynamicFn) {\nthis.__addAnnotatedComputationEffect(sig.method, index, note, part, null);\n}\n}\n},\n__addAnnotatedComputationEffect: function (property, index, note, part, trigger) {\nthis._addPropertyEffect(property, 'annotatedComputation', {\nindex: index,\nisCompound: note.isCompound,\ncompoundIndex: part.compoundIndex,\nkind: note.kind,\nname: note.name,\nnegate: part.negate,\nmethod: part.signature.method,\nargs: part.signature.args,\ntrigger: trigger,\ndynamicFn: part.signature.dynamicFn\n});\n},\n_parseMethod: function (expression) {\nvar m = expression.match(/([^\\s]+?)\\(([\\s\\S]*)\\)/);\nif (m) {\nvar sig = {\nmethod: m[1],\nstatic: true\n};\nif (this.getPropertyInfo(sig.method) !== Polymer.nob) {\nsig.static = false;\nsig.dynamicFn = true;\n}\nif (m[2].trim()) {\nvar args = m[2].replace(/\\\\,/g, '&comma;').split(',');\nreturn this._parseArgs(args, sig);\n} else {\nsig.args = Polymer.nar;\nreturn sig;\n}\n}\n},\n_parseArgs: function (argList, sig) {\nsig.args = argList.map(function (rawArg) {\nvar arg = this._parseArg(rawArg);\nif (!arg.literal) {\nsig.static = false;\n}\nreturn arg;\n}, this);\nreturn sig;\n},\n_parseArg: function (rawArg) {\nvar arg = rawArg.trim().replace(/&comma;/g, ',').replace(/\\\\(.)/g, '$1');\nvar a = { name: arg };\nvar fc = arg[0];\nif (fc === '-') {\nfc = arg[1];\n}\nif (fc >= '0' && fc <= '9') {\nfc = '#';\n}\nswitch (fc) {\ncase '\\'':\ncase '\"':\na.value = arg.slice(1, -1);\na.literal = true;\nbreak;\ncase '#':\na.value = Number(arg);\na.literal = true;\nbreak;\n}\nif (!a.literal) {\na.model = this._modelForPath(arg);\na.structured = arg.indexOf('.') > 0;\nif (a.structured) {\na.wildcard = arg.slice(-2) == '.*';\nif (a.wildcard) {\na.name = arg.slice(0, -2);\n}\n}\n}\nreturn a;\n},\n_marshalInstanceEffects: function () {\nPolymer.Bind.prepareInstance(this);\nif (this._bindListeners) {\nPolymer.Bind.setupBindListeners(this);\n}\n},\n_applyEffectValue: function (info, value) {\nvar node = this._nodes[info.index];\nvar property = info.name;\nvalue = this._computeFinalAnnotationValue(node, property, value, info);\nif (info.kind == 'attribute') {\nthis.serializeValueToAttribute(value, property, node);\n} else {\nvar pinfo = node._propertyInfo && node._propertyInfo[property];\nif (pinfo && pinfo.readOnly) {\nreturn;\n}\nthis.__setProperty(property, value, false, node);\n}\n},\n_computeFinalAnnotationValue: function (node, property, value, info) {\nif (info.negate) {\nvalue = !value;\n}\nif (info.isCompound) {\nvar storage = node.__compoundStorage__[property];\nstorage[info.compoundIndex] = value;\nvalue = storage.join('');\n}\nif (info.kind !== 'attribute') {\nif (property === 'className') {\nvalue = this._scopeElementClass(node, value);\n}\nif (property === 'textContent' || node.localName == 'input' && property == 'value') {\nvalue = value == undefined ? '' : value;\n}\n}\nreturn value;\n},\n_executeStaticEffects: function () {\nif (this._propertyEffects && this._propertyEffects.__static__) {\nthis._effectEffects('__static__', null, this._propertyEffects.__static__);\n}\n}\n});(function () {\nvar usePolyfillProto = Polymer.Settings.usePolyfillProto;\nPolymer.Base._addFeature({\n_setupConfigure: function (initialConfig) {\nthis._config = {};\nthis._handlers = [];\nthis._aboveConfig = null;\nif (initialConfig) {\nfor (var i in initialConfig) {\nif (initialConfig[i] !== undefined) {\nthis._config[i] = initialConfig[i];\n}\n}\n}\n},\n_marshalAttributes: function () {\nthis._takeAttributesToModel(this._config);\n},\n_attributeChangedImpl: function (name) {\nvar model = this._clientsReadied ? this : this._config;\nthis._setAttributeToProperty(model, name);\n},\n_configValue: function (name, value) {\nvar info = this._propertyInfo[name];\nif (!info || !info.readOnly) {\nthis._config[name] = value;\n}\n},\n_beforeClientsReady: function () {\nthis._configure();\n},\n_configure: function () {\nthis._configureAnnotationReferences();\nthis._configureInstanceProperties();\nthis._aboveConfig = this.mixin({}, this._config);\nvar config = {};\nfor (var i = 0; i < this.behaviors.length; i++) {\nthis._configureProperties(this.behaviors[i].properties, config);\n}\nthis._configureProperties(this.properties, config);\nthis.mixin(config, this._aboveConfig);\nthis._config = config;\nif (this._clients && this._clients.length) {\nthis._distributeConfig(this._config);\n}\n},\n_configureInstanceProperties: function () {\nfor (var i in this._propertyEffects) {\nif (!usePolyfillProto && this.hasOwnProperty(i)) {\nthis._configValue(i, this[i]);\ndelete this[i];\n}\n}\n},\n_configureProperties: function (properties, config) {\nfor (var i in properties) {\nvar c = properties[i];\nif (c.value !== undefined) {\nvar value = c.value;\nif (typeof value == 'function') {\nvalue = value.call(this, this._config);\n}\nconfig[i] = value;\n}\n}\n},\n_distributeConfig: function (config) {\nvar fx$ = this._propertyEffects;\nif (fx$) {\nfor (var p in config) {\nvar fx = fx$[p];\nif (fx) {\nfor (var i = 0, l = fx.length, x; i < l && (x = fx[i]); i++) {\nif (x.kind === 'annotation') {\nvar node = this._nodes[x.effect.index];\nvar name = x.effect.propertyName;\nvar isAttr = x.effect.kind == 'attribute';\nvar hasEffect = node._propertyEffects && node._propertyEffects[name];\nif (node._configValue && (hasEffect || !isAttr)) {\nvar value = p === x.effect.value ? config[p] : this._get(x.effect.value, config);\nvalue = this._computeFinalAnnotationValue(node, name, value, x.effect);\nif (isAttr) {\nvalue = node.deserialize(this.serialize(value), node._propertyInfo[name].type);\n}\nnode._configValue(name, value);\n}\n}\n}\n}\n}\n}\n},\n_afterClientsReady: function () {\nthis._executeStaticEffects();\nthis._applyConfig(this._config, this._aboveConfig);\nthis._flushHandlers();\n},\n_applyConfig: function (config, aboveConfig) {\nfor (var n in config) {\nif (this[n] === undefined) {\nthis.__setProperty(n, config[n], n in aboveConfig);\n}\n}\n},\n_notifyListener: function (fn, e) {\nif (!Polymer.Bind._isEventBogus(e, e.target)) {\nvar value, path;\nif (e.detail) {\nvalue = e.detail.value;\npath = e.detail.path;\n}\nif (!this._clientsReadied) {\nthis._queueHandler([\nfn,\ne.target,\nvalue,\npath\n]);\n} else {\nreturn fn.call(this, e.target, value, path);\n}\n}\n},\n_queueHandler: function (args) {\nthis._handlers.push(args);\n},\n_flushHandlers: function () {\nvar h$ = this._handlers;\nfor (var i = 0, l = h$.length, h; i < l && (h = h$[i]); i++) {\nh[0].call(this, h[1], h[2], h[3]);\n}\nthis._handlers = [];\n}\n});\n}());(function () {\n'use strict';\nPolymer.Base._addFeature({\nnotifyPath: function (path, value, fromAbove) {\nvar info = {};\nvar v = this._get(path, this, info);\nif (arguments.length === 1) {\nvalue = v;\n}\nif (info.path) {\nthis._notifyPath(info.path, value, fromAbove);\n}\n},\n_notifyPath: function (path, value, fromAbove) {\nvar old = this._propertySetter(path, value);\nif (old !== value && (old === old || value === value)) {\nthis._pathEffector(path, value);\nif (!fromAbove) {\nthis._notifyPathUp(path, value);\n}\nreturn true;\n}\n},\n_getPathParts: function (path) {\nif (Array.isArray(path)) {\nvar parts = [];\nfor (var i = 0; i < path.length; i++) {\nvar args = path[i].toString().split('.');\nfor (var j = 0; j < args.length; j++) {\nparts.push(args[j]);\n}\n}\nreturn parts;\n} else {\nreturn path.toString().split('.');\n}\n},\nset: function (path, value, root) {\nvar prop = root || this;\nvar parts = this._getPathParts(path);\nvar array;\nvar last = parts[parts.length - 1];\nif (parts.length > 1) {\nfor (var i = 0; i < parts.length - 1; i++) {\nvar part = parts[i];\nif (array && part[0] == '#') {\nprop = Polymer.Collection.get(array).getItem(part);\n} else {\nprop = prop[part];\nif (array && parseInt(part, 10) == part) {\nparts[i] = Polymer.Collection.get(array).getKey(prop);\n}\n}\nif (!prop) {\nreturn;\n}\narray = Array.isArray(prop) ? prop : null;\n}\nif (array) {\nvar coll = Polymer.Collection.get(array);\nvar old, key;\nif (last[0] == '#') {\nkey = last;\nold = coll.getItem(key);\nlast = array.indexOf(old);\ncoll.setItem(key, value);\n} else if (parseInt(last, 10) == last) {\nold = prop[last];\nkey = coll.getKey(old);\nparts[i] = key;\ncoll.setItem(key, value);\n}\n}\nprop[last] = value;\nif (!root) {\nthis._notifyPath(parts.join('.'), value);\n}\n} else {\nprop[path] = value;\n}\n},\nget: function (path, root) {\nreturn this._get(path, root);\n},\n_get: function (path, root, info) {\nvar prop = root || this;\nvar parts = this._getPathParts(path);\nvar array;\nfor (var i = 0; i < parts.length; i++) {\nif (!prop) {\nreturn;\n}\nvar part = parts[i];\nif (array && part[0] == '#') {\nprop = Polymer.Collection.get(array).getItem(part);\n} else {\nprop = prop[part];\nif (info && array && parseInt(part, 10) == part) {\nparts[i] = Polymer.Collection.get(array).getKey(prop);\n}\n}\narray = Array.isArray(prop) ? prop : null;\n}\nif (info) {\ninfo.path = parts.join('.');\n}\nreturn prop;\n},\n_pathEffector: function (path, value) {\nvar model = this._modelForPath(path);\nvar fx$ = this._propertyEffects && this._propertyEffects[model];\nif (fx$) {\nfor (var i = 0, fx; i < fx$.length && (fx = fx$[i]); i++) {\nvar fxFn = fx.pathFn;\nif (fxFn) {\nfxFn.call(this, path, value, fx.effect);\n}\n}\n}\nif (this._boundPaths) {\nthis._notifyBoundPaths(path, value);\n}\n},\n_annotationPathEffect: function (path, value, effect) {\nif (effect.value === path || effect.value.indexOf(path + '.') === 0) {\nPolymer.Bind._annotationEffect.call(this, path, value, effect);\n} else if (path.indexOf(effect.value + '.') === 0 && !effect.negate) {\nvar node = this._nodes[effect.index];\nif (node && node._notifyPath) {\nvar p = this._fixPath(effect.name, effect.value, path);\nnode._notifyPath(p, value, true);\n}\n}\n},\n_complexObserverPathEffect: function (path, value, effect) {\nif (this._pathMatchesEffect(path, effect)) {\nPolymer.Bind._complexObserverEffect.call(this, path, value, effect);\n}\n},\n_computePathEffect: function (path, value, effect) {\nif (this._pathMatchesEffect(path, effect)) {\nPolymer.Bind._computeEffect.call(this, path, value, effect);\n}\n},\n_annotatedComputationPathEffect: function (path, value, effect) {\nif (this._pathMatchesEffect(path, effect)) {\nPolymer.Bind._annotatedComputationEffect.call(this, path, value, effect);\n}\n},\n_pathMatchesEffect: function (path, effect) {\nvar effectArg = effect.trigger.name;\nreturn effectArg == path || effectArg.indexOf(path + '.') === 0 || effect.trigger.wildcard && path.indexOf(effectArg + '.') === 0;\n},\nlinkPaths: function (to, from) {\nthis._boundPaths = this._boundPaths || {};\nif (from) {\nthis._boundPaths[to] = from;\n} else {\nthis.unlinkPaths(to);\n}\n},\nunlinkPaths: function (path) {\nif (this._boundPaths) {\ndelete this._boundPaths[path];\n}\n},\n_notifyBoundPaths: function (path, value) {\nfor (var a in this._boundPaths) {\nvar b = this._boundPaths[a];\nif (path.indexOf(a + '.') == 0) {\nthis._notifyPath(this._fixPath(b, a, path), value);\n} else if (path.indexOf(b + '.') == 0) {\nthis._notifyPath(this._fixPath(a, b, path), value);\n}\n}\n},\n_fixPath: function (property, root, path) {\nreturn property + path.slice(root.length);\n},\n_notifyPathUp: function (path, value) {\nvar rootName = this._modelForPath(path);\nvar dashCaseName = Polymer.CaseMap.camelToDashCase(rootName);\nvar eventName = dashCaseName + this._EVENT_CHANGED;\nthis.fire(eventName, {\npath: path,\nvalue: value\n}, {\nbubbles: false,\n_useCache: true\n});\n},\n_modelForPath: function (path) {\nvar dot = path.indexOf('.');\nreturn dot < 0 ? path : path.slice(0, dot);\n},\n_EVENT_CHANGED: '-changed',\nnotifySplices: function (path, splices) {\nvar info = {};\nvar array = this._get(path, this, info);\nthis._notifySplices(array, info.path, splices);\n},\n_notifySplices: function (array, path, splices) {\nvar change = {\nkeySplices: Polymer.Collection.applySplices(array, splices),\nindexSplices: splices\n};\nvar splicesPath = path + '.splices';\nthis._notifyPath(splicesPath, change);\nthis._notifyPath(path + '.length', array.length);\nthis.__data__[splicesPath] = {\nkeySplices: null,\nindexSplices: null\n};\n},\n_notifySplice: function (array, path, index, added, removed) {\nthis._notifySplices(array, path, [{\nindex: index,\naddedCount: added,\nremoved: removed,\nobject: array,\ntype: 'splice'\n}]);\n},\npush: function (path) {\nvar info = {};\nvar array = this._get(path, this, info);\nvar args = Array.prototype.slice.call(arguments, 1);\nvar len = array.length;\nvar ret = array.push.apply(array, args);\nif (args.length) {\nthis._notifySplice(array, info.path, len, args.length, []);\n}\nreturn ret;\n},\npop: function (path) {\nvar info = {};\nvar array = this._get(path, this, info);\nvar hadLength = Boolean(array.length);\nvar args = Array.prototype.slice.call(arguments, 1);\nvar ret = array.pop.apply(array, args);\nif (hadLength) {\nthis._notifySplice(array, info.path, array.length, 0, [ret]);\n}\nreturn ret;\n},\nsplice: function (path, start) {\nvar info = {};\nvar array = this._get(path, this, info);\nif (start < 0) {\nstart = array.length - Math.floor(-start);\n} else {\nstart = Math.floor(start);\n}\nif (!start) {\nstart = 0;\n}\nvar args = Array.prototype.slice.call(arguments, 1);\nvar ret = array.splice.apply(array, args);\nvar addedCount = Math.max(args.length - 2, 0);\nif (addedCount || ret.length) {\nthis._notifySplice(array, info.path, start, addedCount, ret);\n}\nreturn ret;\n},\nshift: function (path) {\nvar info = {};\nvar array = this._get(path, this, info);\nvar hadLength = Boolean(array.length);\nvar args = Array.prototype.slice.call(arguments, 1);\nvar ret = array.shift.apply(array, args);\nif (hadLength) {\nthis._notifySplice(array, info.path, 0, 0, [ret]);\n}\nreturn ret;\n},\nunshift: function (path) {\nvar info = {};\nvar array = this._get(path, this, info);\nvar args = Array.prototype.slice.call(arguments, 1);\nvar ret = array.unshift.apply(array, args);\nif (args.length) {\nthis._notifySplice(array, info.path, 0, args.length, []);\n}\nreturn ret;\n},\nprepareModelNotifyPath: function (model) {\nthis.mixin(model, {\nfire: Polymer.Base.fire,\n_getEvent: Polymer.Base._getEvent,\n__eventCache: Polymer.Base.__eventCache,\nnotifyPath: Polymer.Base.notifyPath,\n_get: Polymer.Base._get,\n_EVENT_CHANGED: Polymer.Base._EVENT_CHANGED,\n_notifyPath: Polymer.Base._notifyPath,\n_notifyPathUp: Polymer.Base._notifyPathUp,\n_pathEffector: Polymer.Base._pathEffector,\n_annotationPathEffect: Polymer.Base._annotationPathEffect,\n_complexObserverPathEffect: Polymer.Base._complexObserverPathEffect,\n_annotatedComputationPathEffect: Polymer.Base._annotatedComputationPathEffect,\n_computePathEffect: Polymer.Base._computePathEffect,\n_modelForPath: Polymer.Base._modelForPath,\n_pathMatchesEffect: Polymer.Base._pathMatchesEffect,\n_notifyBoundPaths: Polymer.Base._notifyBoundPaths,\n_getPathParts: Polymer.Base._getPathParts\n});\n}\n});\n}());Polymer.Base._addFeature({\nresolveUrl: function (url) {\nvar module = Polymer.DomModule.import(this.is);\nvar root = '';\nif (module) {\nvar assetPath = module.getAttribute('assetpath') || '';\nroot = Polymer.ResolveUrl.resolveUrl(assetPath, module.ownerDocument.baseURI);\n}\nreturn Polymer.ResolveUrl.resolveUrl(url, root);\n}\n});Polymer.CssParse = function () {\nreturn {\nparse: function (text) {\ntext = this._clean(text);\nreturn this._parseCss(this._lex(text), text);\n},\n_clean: function (cssText) {\nreturn cssText.replace(this._rx.comments, '').replace(this._rx.port, '');\n},\n_lex: function (text) {\nvar root = {\nstart: 0,\nend: text.length\n};\nvar n = root;\nfor (var i = 0, l = text.length; i < l; i++) {\nswitch (text[i]) {\ncase this.OPEN_BRACE:\nif (!n.rules) {\nn.rules = [];\n}\nvar p = n;\nvar previous = p.rules[p.rules.length - 1];\nn = {\nstart: i + 1,\nparent: p,\nprevious: previous\n};\np.rules.push(n);\nbreak;\ncase this.CLOSE_BRACE:\nn.end = i + 1;\nn = n.parent || root;\nbreak;\n}\n}\nreturn root;\n},\n_parseCss: function (node, text) {\nvar t = text.substring(node.start, node.end - 1);\nnode.parsedCssText = node.cssText = t.trim();\nif (node.parent) {\nvar ss = node.previous ? node.previous.end : node.parent.start;\nt = text.substring(ss, node.start - 1);\nt = this._expandUnicodeEscapes(t);\nt = t.replace(this._rx.multipleSpaces, ' ');\nt = t.substring(t.lastIndexOf(';') + 1);\nvar s = node.parsedSelector = node.selector = t.trim();\nnode.atRule = s.indexOf(this.AT_START) === 0;\nif (node.atRule) {\nif (s.indexOf(this.MEDIA_START) === 0) {\nnode.type = this.types.MEDIA_RULE;\n} else if (s.match(this._rx.keyframesRule)) {\nnode.type = this.types.KEYFRAMES_RULE;\nnode.keyframesName = node.selector.split(this._rx.multipleSpaces).pop();\n}\n} else {\nif (s.indexOf(this.VAR_START) === 0) {\nnode.type = this.types.MIXIN_RULE;\n} else {\nnode.type = this.types.STYLE_RULE;\n}\n}\n}\nvar r$ = node.rules;\nif (r$) {\nfor (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\nthis._parseCss(r, text);\n}\n}\nreturn node;\n},\n_expandUnicodeEscapes: function (s) {\nreturn s.replace(/\\\\([0-9a-f]{1,6})\\s/gi, function () {\nvar code = arguments[1], repeat = 6 - code.length;\nwhile (repeat--) {\ncode = '0' + code;\n}\nreturn '\\\\' + code;\n});\n},\nstringify: function (node, preserveProperties, text) {\ntext = text || '';\nvar cssText = '';\nif (node.cssText || node.rules) {\nvar r$ = node.rules;\nif (r$ && !this._hasMixinRules(r$)) {\nfor (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\ncssText = this.stringify(r, preserveProperties, cssText);\n}\n} else {\ncssText = preserveProperties ? node.cssText : this.removeCustomProps(node.cssText);\ncssText = cssText.trim();\nif (cssText) {\ncssText = '  ' + cssText + '\\n';\n}\n}\n}\nif (cssText) {\nif (node.selector) {\ntext += node.selector + ' ' + this.OPEN_BRACE + '\\n';\n}\ntext += cssText;\nif (node.selector) {\ntext += this.CLOSE_BRACE + '\\n\\n';\n}\n}\nreturn text;\n},\n_hasMixinRules: function (rules) {\nreturn rules[0].selector.indexOf(this.VAR_START) === 0;\n},\nremoveCustomProps: function (cssText) {\ncssText = this.removeCustomPropAssignment(cssText);\nreturn this.removeCustomPropApply(cssText);\n},\nremoveCustomPropAssignment: function (cssText) {\nreturn cssText.replace(this._rx.customProp, '').replace(this._rx.mixinProp, '');\n},\nremoveCustomPropApply: function (cssText) {\nreturn cssText.replace(this._rx.mixinApply, '').replace(this._rx.varApply, '');\n},\ntypes: {\nSTYLE_RULE: 1,\nKEYFRAMES_RULE: 7,\nMEDIA_RULE: 4,\nMIXIN_RULE: 1000\n},\nOPEN_BRACE: '{',\nCLOSE_BRACE: '}',\n_rx: {\ncomments: /\\/\\*[^*]*\\*+([^\\/*][^*]*\\*+)*\\//gim,\nport: /@import[^;]*;/gim,\ncustomProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?(?:[;\\n]|$)/gim,\nmixinProp: /(?:^[^;\\-\\s}]+)?--[^;{}]*?:[^{};]*?{[^}]*?}(?:[;\\n]|$)?/gim,\nmixinApply: /@apply\\s*\\(?[^);]*\\)?\\s*(?:[;\\n]|$)?/gim,\nvarApply: /[^;:]*?:[^;]*?var\\([^;]*\\)(?:[;\\n]|$)?/gim,\nkeyframesRule: /^@[^\\s]*keyframes/,\nmultipleSpaces: /\\s+/g\n},\nVAR_START: '--',\nMEDIA_START: '@media',\nAT_START: '@'\n};\n}();Polymer.StyleUtil = function () {\nvar settings = Polymer.Settings;\nreturn {\nNATIVE_VARIABLES: Polymer.Settings.useNativeCSSProperties,\nMODULE_STYLES_SELECTOR: 'style, link[rel=import][type~=css], template',\nINCLUDE_ATTR: 'include',\ntoCssText: function (rules, callback) {\nif (typeof rules === 'string') {\nrules = this.parser.parse(rules);\n}\nif (callback) {\nthis.forEachRule(rules, callback);\n}\nreturn this.parser.stringify(rules, this.NATIVE_VARIABLES);\n},\nforRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {\nif (styles) {\nfor (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {\nthis.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback);\n}\n}\n},\nforActiveRulesInStyles: function (styles, styleRuleCallback, keyframesRuleCallback) {\nif (styles) {\nfor (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {\nthis.forEachRuleInStyle(s, styleRuleCallback, keyframesRuleCallback, true);\n}\n}\n},\nrulesForStyle: function (style) {\nif (!style.__cssRules && style.textContent) {\nstyle.__cssRules = this.parser.parse(style.textContent);\n}\nreturn style.__cssRules;\n},\nisKeyframesSelector: function (rule) {\nreturn rule.parent && rule.parent.type === this.ruleTypes.KEYFRAMES_RULE;\n},\nforEachRuleInStyle: function (style, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\nvar rules = this.rulesForStyle(style);\nvar styleCallback, keyframeCallback;\nif (styleRuleCallback) {\nstyleCallback = function (rule) {\nstyleRuleCallback(rule, style);\n};\n}\nif (keyframesRuleCallback) {\nkeyframeCallback = function (rule) {\nkeyframesRuleCallback(rule, style);\n};\n}\nthis.forEachRule(rules, styleCallback, keyframeCallback, onlyActiveRules);\n},\nforEachRule: function (node, styleRuleCallback, keyframesRuleCallback, onlyActiveRules) {\nif (!node) {\nreturn;\n}\nvar skipRules = false;\nif (onlyActiveRules) {\nif (node.type === this.ruleTypes.MEDIA_RULE) {\nvar matchMedia = node.selector.match(this.rx.MEDIA_MATCH);\nif (matchMedia) {\nif (!window.matchMedia(matchMedia[1]).matches) {\nskipRules = true;\n}\n}\n}\n}\nif (node.type === this.ruleTypes.STYLE_RULE) {\nstyleRuleCallback(node);\n} else if (keyframesRuleCallback && node.type === this.ruleTypes.KEYFRAMES_RULE) {\nkeyframesRuleCallback(node);\n} else if (node.type === this.ruleTypes.MIXIN_RULE) {\nskipRules = true;\n}\nvar r$ = node.rules;\nif (r$ && !skipRules) {\nfor (var i = 0, l = r$.length, r; i < l && (r = r$[i]); i++) {\nthis.forEachRule(r, styleRuleCallback, keyframesRuleCallback, onlyActiveRules);\n}\n}\n},\napplyCss: function (cssText, moniker, target, contextNode) {\nvar style = this.createScopeStyle(cssText, moniker);\nreturn this.applyStyle(style, target, contextNode);\n},\napplyStyle: function (style, target, contextNode) {\ntarget = target || document.head;\nvar after = contextNode && contextNode.nextSibling || target.firstChild;\nthis.__lastHeadApplyNode = style;\nreturn target.insertBefore(style, after);\n},\ncreateScopeStyle: function (cssText, moniker) {\nvar style = document.createElement('style');\nif (moniker) {\nstyle.setAttribute('scope', moniker);\n}\nstyle.textContent = cssText;\nreturn style;\n},\n__lastHeadApplyNode: null,\napplyStylePlaceHolder: function (moniker) {\nvar placeHolder = document.createComment(' Shady DOM styles for ' + moniker + ' ');\nvar after = this.__lastHeadApplyNode ? this.__lastHeadApplyNode.nextSibling : null;\nvar scope = document.head;\nscope.insertBefore(placeHolder, after || scope.firstChild);\nthis.__lastHeadApplyNode = placeHolder;\nreturn placeHolder;\n},\ncssFromModules: function (moduleIds, warnIfNotFound) {\nvar modules = moduleIds.trim().split(' ');\nvar cssText = '';\nfor (var i = 0; i < modules.length; i++) {\ncssText += this.cssFromModule(modules[i], warnIfNotFound);\n}\nreturn cssText;\n},\ncssFromModule: function (moduleId, warnIfNotFound) {\nvar m = Polymer.DomModule.import(moduleId);\nif (m && !m._cssText) {\nm._cssText = this.cssFromElement(m);\n}\nif (!m && warnIfNotFound) {\nconsole.warn('Could not find style data in module named', moduleId);\n}\nreturn m && m._cssText || '';\n},\ncssFromElement: function (element) {\nvar cssText = '';\nvar content = element.content || element;\nvar e$ = Polymer.TreeApi.arrayCopy(content.querySelectorAll(this.MODULE_STYLES_SELECTOR));\nfor (var i = 0, e; i < e$.length; i++) {\ne = e$[i];\nif (e.localName === 'template') {\ncssText += this.cssFromElement(e);\n} else {\nif (e.localName === 'style') {\nvar include = e.getAttribute(this.INCLUDE_ATTR);\nif (include) {\ncssText += this.cssFromModules(include, true);\n}\ne = e.__appliedElement || e;\ne.parentNode.removeChild(e);\ncssText += this.resolveCss(e.textContent, element.ownerDocument);\n} else if (e.import && e.import.body) {\ncssText += this.resolveCss(e.import.body.textContent, e.import);\n}\n}\n}\nreturn cssText;\n},\nisTargetedBuild: function (buildType) {\nreturn settings.useNativeShadow ? buildType === 'shadow' : buildType === 'shady';\n},\ncssBuildTypeForModule: function (module) {\nvar dm = Polymer.DomModule.import(module);\nif (dm) {\nreturn this.getCssBuildType(dm);\n}\n},\ngetCssBuildType: function (element) {\nreturn element.getAttribute('css-build');\n},\n_findMatchingParen: function (text, start) {\nvar level = 0;\nfor (var i = start, l = text.length; i < l; i++) {\nswitch (text[i]) {\ncase '(':\nlevel++;\nbreak;\ncase ')':\nif (--level === 0) {\nreturn i;\n}\nbreak;\n}\n}\nreturn -1;\n},\nprocessVariableAndFallback: function (str, callback) {\nvar start = str.indexOf('var(');\nif (start === -1) {\nreturn callback(str, '', '', '');\n}\nvar end = this._findMatchingParen(str, start + 3);\nvar inner = str.substring(start + 4, end);\nvar prefix = str.substring(0, start);\nvar suffix = this.processVariableAndFallback(str.substring(end + 1), callback);\nvar comma = inner.indexOf(',');\nif (comma === -1) {\nreturn callback(prefix, inner.trim(), '', suffix);\n}\nvar value = inner.substring(0, comma).trim();\nvar fallback = inner.substring(comma + 1).trim();\nreturn callback(prefix, value, fallback, suffix);\n},\nrx: {\nVAR_ASSIGN: /(?:^|[;\\s{]\\s*)(--[\\w-]*?)\\s*:\\s*(?:([^;{]*)|{([^}]*)})(?:(?=[;\\s}])|$)/gi,\nMIXIN_MATCH: /(?:^|\\W+)@apply\\s*\\(?([^);\\n]*)\\)?/gi,\nVAR_CONSUMED: /(--[\\w-]+)\\s*([:,;)]|$)/gi,\nANIMATION_MATCH: /(animation\\s*:)|(animation-name\\s*:)/,\nMEDIA_MATCH: /@media[^(]*(\\([^)]*\\))/,\nIS_VAR: /^--/,\nBRACKETED: /\\{[^}]*\\}/g,\nHOST_PREFIX: '(?:^|[^.#[:])',\nHOST_SUFFIX: '($|[.:[\\\\s>+~])'\n},\nresolveCss: Polymer.ResolveUrl.resolveCss,\nparser: Polymer.CssParse,\nruleTypes: Polymer.CssParse.types\n};\n}();Polymer.StyleTransformer = function () {\nvar styleUtil = Polymer.StyleUtil;\nvar settings = Polymer.Settings;\nvar api = {\ndom: function (node, scope, useAttr, shouldRemoveScope) {\nthis._transformDom(node, scope || '', useAttr, shouldRemoveScope);\n},\n_transformDom: function (node, selector, useAttr, shouldRemoveScope) {\nif (node.setAttribute) {\nthis.element(node, selector, useAttr, shouldRemoveScope);\n}\nvar c$ = Polymer.dom(node).childNodes;\nfor (var i = 0; i < c$.length; i++) {\nthis._transformDom(c$[i], selector, useAttr, shouldRemoveScope);\n}\n},\nelement: function (element, scope, useAttr, shouldRemoveScope) {\nif (useAttr) {\nif (shouldRemoveScope) {\nelement.removeAttribute(SCOPE_NAME);\n} else {\nelement.setAttribute(SCOPE_NAME, scope);\n}\n} else {\nif (scope) {\nif (element.classList) {\nif (shouldRemoveScope) {\nelement.classList.remove(SCOPE_NAME);\nelement.classList.remove(scope);\n} else {\nelement.classList.add(SCOPE_NAME);\nelement.classList.add(scope);\n}\n} else if (element.getAttribute) {\nvar c = element.getAttribute(CLASS);\nif (shouldRemoveScope) {\nif (c) {\nelement.setAttribute(CLASS, c.replace(SCOPE_NAME, '').replace(scope, ''));\n}\n} else {\nelement.setAttribute(CLASS, (c ? c + ' ' : '') + SCOPE_NAME + ' ' + scope);\n}\n}\n}\n}\n},\nelementStyles: function (element, callback) {\nvar styles = element._styles;\nvar cssText = '';\nvar cssBuildType = element.__cssBuild;\nfor (var i = 0, l = styles.length, s; i < l && (s = styles[i]); i++) {\nvar rules = styleUtil.rulesForStyle(s);\ncssText += settings.useNativeShadow || cssBuildType === 'shady' ? styleUtil.toCssText(rules, callback) : this.css(rules, element.is, element.extends, callback, element._scopeCssViaAttr) + '\\n\\n';\n}\nreturn cssText.trim();\n},\ncss: function (rules, scope, ext, callback, useAttr) {\nvar hostScope = this._calcHostScope(scope, ext);\nscope = this._calcElementScope(scope, useAttr);\nvar self = this;\nreturn styleUtil.toCssText(rules, function (rule) {\nif (!rule.isScoped) {\nself.rule(rule, scope, hostScope);\nrule.isScoped = true;\n}\nif (callback) {\ncallback(rule, scope, hostScope);\n}\n});\n},\n_calcElementScope: function (scope, useAttr) {\nif (scope) {\nreturn useAttr ? CSS_ATTR_PREFIX + scope + CSS_ATTR_SUFFIX : CSS_CLASS_PREFIX + scope;\n} else {\nreturn '';\n}\n},\n_calcHostScope: function (scope, ext) {\nreturn ext ? '[is=' + scope + ']' : scope;\n},\nrule: function (rule, scope, hostScope) {\nthis._transformRule(rule, this._transformComplexSelector, scope, hostScope);\n},\n_transformRule: function (rule, transformer, scope, hostScope) {\nrule.selector = rule.transformedSelector = this._transformRuleCss(rule, transformer, scope, hostScope);\n},\n_transformRuleCss: function (rule, transformer, scope, hostScope) {\nvar p$ = rule.selector.split(COMPLEX_SELECTOR_SEP);\nif (!styleUtil.isKeyframesSelector(rule)) {\nfor (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\np$[i] = transformer.call(this, p, scope, hostScope);\n}\n}\nreturn p$.join(COMPLEX_SELECTOR_SEP);\n},\n_transformComplexSelector: function (selector, scope, hostScope) {\nvar stop = false;\nvar hostContext = false;\nvar self = this;\nselector = selector.trim();\nselector = selector.replace(CONTENT_START, HOST + ' $1');\nselector = selector.replace(SIMPLE_SELECTOR_SEP, function (m, c, s) {\nif (!stop) {\nvar info = self._transformCompoundSelector(s, c, scope, hostScope);\nstop = stop || info.stop;\nhostContext = hostContext || info.hostContext;\nc = info.combinator;\ns = info.value;\n} else {\ns = s.replace(SCOPE_JUMP, ' ');\n}\nreturn c + s;\n});\nif (hostContext) {\nselector = selector.replace(HOST_CONTEXT_PAREN, function (m, pre, paren, post) {\nreturn pre + paren + ' ' + hostScope + post + COMPLEX_SELECTOR_SEP + ' ' + pre + hostScope + paren + post;\n});\n}\nreturn selector;\n},\n_transformCompoundSelector: function (selector, combinator, scope, hostScope) {\nvar jumpIndex = selector.search(SCOPE_JUMP);\nvar hostContext = false;\nif (selector.indexOf(HOST_CONTEXT) >= 0) {\nhostContext = true;\n} else if (selector.indexOf(HOST) >= 0) {\nselector = this._transformHostSelector(selector, hostScope);\n} else if (jumpIndex !== 0) {\nselector = scope ? this._transformSimpleSelector(selector, scope) : selector;\n}\nif (selector.indexOf(CONTENT) >= 0) {\ncombinator = '';\n}\nvar stop;\nif (jumpIndex >= 0) {\nselector = selector.replace(SCOPE_JUMP, ' ');\nstop = true;\n}\nreturn {\nvalue: selector,\ncombinator: combinator,\nstop: stop,\nhostContext: hostContext\n};\n},\n_transformSimpleSelector: function (selector, scope) {\nvar p$ = selector.split(PSEUDO_PREFIX);\np$[0] += scope;\nreturn p$.join(PSEUDO_PREFIX);\n},\n_transformHostSelector: function (selector, hostScope) {\nvar m = selector.match(HOST_PAREN);\nvar paren = m && m[2].trim() || '';\nif (paren) {\nif (!paren[0].match(SIMPLE_SELECTOR_PREFIX)) {\nvar typeSelector = paren.split(SIMPLE_SELECTOR_PREFIX)[0];\nif (typeSelector === hostScope) {\nreturn paren;\n} else {\nreturn SELECTOR_NO_MATCH;\n}\n} else {\nreturn selector.replace(HOST_PAREN, function (m, host, paren) {\nreturn hostScope + paren;\n});\n}\n} else {\nreturn selector.replace(HOST, hostScope);\n}\n},\ndocumentRule: function (rule) {\nrule.selector = rule.parsedSelector;\nthis.normalizeRootSelector(rule);\nif (!settings.useNativeShadow) {\nthis._transformRule(rule, this._transformDocumentSelector);\n}\n},\nnormalizeRootSelector: function (rule) {\nif (rule.selector === ROOT) {\nrule.selector = 'html';\n}\n},\n_transformDocumentSelector: function (selector) {\nreturn selector.match(SCOPE_JUMP) ? this._transformComplexSelector(selector, SCOPE_DOC_SELECTOR) : this._transformSimpleSelector(selector.trim(), SCOPE_DOC_SELECTOR);\n},\nSCOPE_NAME: 'style-scope'\n};\nvar SCOPE_NAME = api.SCOPE_NAME;\nvar SCOPE_DOC_SELECTOR = ':not([' + SCOPE_NAME + '])' + ':not(.' + SCOPE_NAME + ')';\nvar COMPLEX_SELECTOR_SEP = ',';\nvar SIMPLE_SELECTOR_SEP = /(^|[\\s>+~]+)((?:\\[.+?\\]|[^\\s>+~=\\[])+)/g;\nvar SIMPLE_SELECTOR_PREFIX = /[[.:#*]/;\nvar HOST = ':host';\nvar ROOT = ':root';\nvar HOST_PAREN = /(:host)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))/;\nvar HOST_CONTEXT = ':host-context';\nvar HOST_CONTEXT_PAREN = /(.*)(?::host-context)(?:\\(((?:\\([^)(]*\\)|[^)(]*)+?)\\))(.*)/;\nvar CONTENT = '::content';\nvar SCOPE_JUMP = /::content|::shadow|\\/deep\\//;\nvar CSS_CLASS_PREFIX = '.';\nvar CSS_ATTR_PREFIX = '[' + SCOPE_NAME + '~=';\nvar CSS_ATTR_SUFFIX = ']';\nvar PSEUDO_PREFIX = ':';\nvar CLASS = 'class';\nvar CONTENT_START = new RegExp('^(' + CONTENT + ')');\nvar SELECTOR_NO_MATCH = 'should_not_match';\nreturn api;\n}();Polymer.StyleExtends = function () {\nvar styleUtil = Polymer.StyleUtil;\nreturn {\nhasExtends: function (cssText) {\nreturn Boolean(cssText.match(this.rx.EXTEND));\n},\ntransform: function (style) {\nvar rules = styleUtil.rulesForStyle(style);\nvar self = this;\nstyleUtil.forEachRule(rules, function (rule) {\nself._mapRuleOntoParent(rule);\nif (rule.parent) {\nvar m;\nwhile (m = self.rx.EXTEND.exec(rule.cssText)) {\nvar extend = m[1];\nvar extendor = self._findExtendor(extend, rule);\nif (extendor) {\nself._extendRule(rule, extendor);\n}\n}\n}\nrule.cssText = rule.cssText.replace(self.rx.EXTEND, '');\n});\nreturn styleUtil.toCssText(rules, function (rule) {\nif (rule.selector.match(self.rx.STRIP)) {\nrule.cssText = '';\n}\n}, true);\n},\n_mapRuleOntoParent: function (rule) {\nif (rule.parent) {\nvar map = rule.parent.map || (rule.parent.map = {});\nvar parts = rule.selector.split(',');\nfor (var i = 0, p; i < parts.length; i++) {\np = parts[i];\nmap[p.trim()] = rule;\n}\nreturn map;\n}\n},\n_findExtendor: function (extend, rule) {\nreturn rule.parent && rule.parent.map && rule.parent.map[extend] || this._findExtendor(extend, rule.parent);\n},\n_extendRule: function (target, source) {\nif (target.parent !== source.parent) {\nthis._cloneAndAddRuleToParent(source, target.parent);\n}\ntarget.extends = target.extends || [];\ntarget.extends.push(source);\nsource.selector = source.selector.replace(this.rx.STRIP, '');\nsource.selector = (source.selector && source.selector + ',\\n') + target.selector;\nif (source.extends) {\nsource.extends.forEach(function (e) {\nthis._extendRule(target, e);\n}, this);\n}\n},\n_cloneAndAddRuleToParent: function (rule, parent) {\nrule = Object.create(rule);\nrule.parent = parent;\nif (rule.extends) {\nrule.extends = rule.extends.slice();\n}\nparent.rules.push(rule);\n},\nrx: {\nEXTEND: /@extends\\(([^)]*)\\)\\s*?;/gim,\nSTRIP: /%[^,]*$/\n}\n};\n}();Polymer.ApplyShim = function () {\n'use strict';\nvar styleUtil = Polymer.StyleUtil;\nvar MIXIN_MATCH = styleUtil.rx.MIXIN_MATCH;\nvar VAR_ASSIGN = styleUtil.rx.VAR_ASSIGN;\nvar BAD_VAR = /var\\(\\s*(--[^,]*),\\s*(--[^)]*)\\)/g;\nvar APPLY_NAME_CLEAN = /;\\s*/m;\nvar INITIAL_INHERIT = /^\\s*(initial)|(inherit)\\s*$/;\nvar MIXIN_VAR_SEP = '_-_';\nvar mixinMap = {};\nfunction mapSet(name, props) {\nname = name.trim();\nmixinMap[name] = {\nproperties: props,\ndependants: {}\n};\n}\nfunction mapGet(name) {\nname = name.trim();\nreturn mixinMap[name];\n}\nfunction replaceInitialOrInherit(property, value) {\nvar match = INITIAL_INHERIT.exec(value);\nif (match) {\nif (match[1]) {\nvalue = ApplyShim._getInitialValueForProperty(property);\n} else {\nvalue = 'apply-shim-inherit';\n}\n}\nreturn value;\n}\nfunction cssTextToMap(text) {\nvar props = text.split(';');\nvar property, value;\nvar out = {};\nfor (var i = 0, p, sp; i < props.length; i++) {\np = props[i];\nif (p) {\nsp = p.split(':');\nif (sp.length > 1) {\nproperty = sp[0].trim();\nvalue = replaceInitialOrInherit(property, sp.slice(1).join(':'));\nout[property] = value;\n}\n}\n}\nreturn out;\n}\nfunction invalidateMixinEntry(mixinEntry) {\nvar currentProto = ApplyShim.__currentElementProto;\nvar currentElementName = currentProto && currentProto.is;\nfor (var elementName in mixinEntry.dependants) {\nif (elementName !== currentElementName) {\nmixinEntry.dependants[elementName].__applyShimInvalid = true;\n}\n}\n}\nfunction produceCssProperties(matchText, propertyName, valueProperty, valueMixin) {\nif (valueProperty) {\nstyleUtil.processVariableAndFallback(valueProperty, function (prefix, value) {\nif (value && mapGet(value)) {\nvalueMixin = '@apply ' + value + ';';\n}\n});\n}\nif (!valueMixin) {\nreturn matchText;\n}\nvar mixinAsProperties = consumeCssProperties(valueMixin);\nvar prefix = matchText.slice(0, matchText.indexOf('--'));\nvar mixinValues = cssTextToMap(mixinAsProperties);\nvar combinedProps = mixinValues;\nvar mixinEntry = mapGet(propertyName);\nvar oldProps = mixinEntry && mixinEntry.properties;\nif (oldProps) {\ncombinedProps = Object.create(oldProps);\ncombinedProps = Polymer.Base.mixin(combinedProps, mixinValues);\n} else {\nmapSet(propertyName, combinedProps);\n}\nvar out = [];\nvar p, v;\nvar needToInvalidate = false;\nfor (p in combinedProps) {\nv = mixinValues[p];\nif (v === undefined) {\nv = 'initial';\n}\nif (oldProps && !(p in oldProps)) {\nneedToInvalidate = true;\n}\nout.push(propertyName + MIXIN_VAR_SEP + p + ': ' + v);\n}\nif (needToInvalidate) {\ninvalidateMixinEntry(mixinEntry);\n}\nif (mixinEntry) {\nmixinEntry.properties = combinedProps;\n}\nif (valueProperty) {\nprefix = matchText + ';' + prefix;\n}\nreturn prefix + out.join('; ') + ';';\n}\nfunction fixVars(matchText, varA, varB) {\nreturn 'var(' + varA + ',' + 'var(' + varB + '));';\n}\nfunction atApplyToCssProperties(mixinName, fallbacks) {\nmixinName = mixinName.replace(APPLY_NAME_CLEAN, '');\nvar vars = [];\nvar mixinEntry = mapGet(mixinName);\nif (!mixinEntry) {\nmapSet(mixinName, {});\nmixinEntry = mapGet(mixinName);\n}\nif (mixinEntry) {\nvar currentProto = ApplyShim.__currentElementProto;\nif (currentProto) {\nmixinEntry.dependants[currentProto.is] = currentProto;\n}\nvar p, parts, f;\nfor (p in mixinEntry.properties) {\nf = fallbacks && fallbacks[p];\nparts = [\np,\n': var(',\nmixinName,\nMIXIN_VAR_SEP,\np\n];\nif (f) {\nparts.push(',', f);\n}\nparts.push(')');\nvars.push(parts.join(''));\n}\n}\nreturn vars.join('; ');\n}\nfunction consumeCssProperties(text) {\nvar m;\nwhile (m = MIXIN_MATCH.exec(text)) {\nvar matchText = m[0];\nvar mixinName = m[1];\nvar idx = m.index;\nvar applyPos = idx + matchText.indexOf('@apply');\nvar afterApplyPos = idx + matchText.length;\nvar textBeforeApply = text.slice(0, applyPos);\nvar textAfterApply = text.slice(afterApplyPos);\nvar defaults = cssTextToMap(textBeforeApply);\nvar replacement = atApplyToCssProperties(mixinName, defaults);\ntext = [\ntextBeforeApply,\nreplacement,\ntextAfterApply\n].join('');\nMIXIN_MATCH.lastIndex = idx + replacement.length;\n}\nreturn text;\n}\nvar ApplyShim = {\n_measureElement: null,\n_map: mixinMap,\n_separator: MIXIN_VAR_SEP,\ntransform: function (styles, elementProto) {\nthis.__currentElementProto = elementProto;\nstyleUtil.forRulesInStyles(styles, this._boundTransformRule);\nelementProto.__applyShimInvalid = false;\nthis.__currentElementProto = null;\n},\ntransformRule: function (rule) {\nrule.cssText = this.transformCssText(rule.parsedCssText);\nif (rule.selector === ':root') {\nrule.selector = ':host > *';\n}\n},\ntransformCssText: function (cssText) {\ncssText = cssText.replace(BAD_VAR, fixVars);\ncssText = cssText.replace(VAR_ASSIGN, produceCssProperties);\nreturn consumeCssProperties(cssText);\n},\n_getInitialValueForProperty: function (property) {\nif (!this._measureElement) {\nthis._measureElement = document.createElement('meta');\nthis._measureElement.style.all = 'initial';\ndocument.head.appendChild(this._measureElement);\n}\nreturn window.getComputedStyle(this._measureElement).getPropertyValue(property);\n}\n};\nApplyShim._boundTransformRule = ApplyShim.transformRule.bind(ApplyShim);\nreturn ApplyShim;\n}();(function () {\nvar prepElement = Polymer.Base._prepElement;\nvar nativeShadow = Polymer.Settings.useNativeShadow;\nvar styleUtil = Polymer.StyleUtil;\nvar styleTransformer = Polymer.StyleTransformer;\nvar styleExtends = Polymer.StyleExtends;\nvar applyShim = Polymer.ApplyShim;\nvar settings = Polymer.Settings;\nPolymer.Base._addFeature({\n_prepElement: function (element) {\nif (this._encapsulateStyle && this.__cssBuild !== 'shady') {\nstyleTransformer.element(element, this.is, this._scopeCssViaAttr);\n}\nprepElement.call(this, element);\n},\n_prepStyles: function () {\nif (this._encapsulateStyle === undefined) {\nthis._encapsulateStyle = !nativeShadow;\n}\nif (!nativeShadow) {\nthis._scopeStyle = styleUtil.applyStylePlaceHolder(this.is);\n}\nthis.__cssBuild = styleUtil.cssBuildTypeForModule(this.is);\n},\n_prepShimStyles: function () {\nif (this._template) {\nvar hasTargetedCssBuild = styleUtil.isTargetedBuild(this.__cssBuild);\nif (settings.useNativeCSSProperties && this.__cssBuild === 'shadow' && hasTargetedCssBuild) {\nreturn;\n}\nthis._styles = this._styles || this._collectStyles();\nif (settings.useNativeCSSProperties && !this.__cssBuild) {\napplyShim.transform(this._styles, this);\n}\nvar cssText = settings.useNativeCSSProperties && hasTargetedCssBuild ? this._styles.length && this._styles[0].textContent.trim() : styleTransformer.elementStyles(this);\nthis._prepStyleProperties();\nif (!this._needsStyleProperties() && cssText) {\nstyleUtil.applyCss(cssText, this.is, nativeShadow ? this._template.content : null, this._scopeStyle);\n}\n} else {\nthis._styles = [];\n}\n},\n_collectStyles: function () {\nvar styles = [];\nvar cssText = '', m$ = this.styleModules;\nif (m$) {\nfor (var i = 0, l = m$.length, m; i < l && (m = m$[i]); i++) {\ncssText += styleUtil.cssFromModule(m);\n}\n}\ncssText += styleUtil.cssFromModule(this.is);\nvar p = this._template && this._template.parentNode;\nif (this._template && (!p || p.id.toLowerCase() !== this.is)) {\ncssText += styleUtil.cssFromElement(this._template);\n}\nif (cssText) {\nvar style = document.createElement('style');\nstyle.textContent = cssText;\nif (styleExtends.hasExtends(style.textContent)) {\ncssText = styleExtends.transform(style);\n}\nstyles.push(style);\n}\nreturn styles;\n},\n_elementAdd: function (node) {\nif (this._encapsulateStyle) {\nif (node.__styleScoped) {\nnode.__styleScoped = false;\n} else {\nstyleTransformer.dom(node, this.is, this._scopeCssViaAttr);\n}\n}\n},\n_elementRemove: function (node) {\nif (this._encapsulateStyle) {\nstyleTransformer.dom(node, this.is, this._scopeCssViaAttr, true);\n}\n},\nscopeSubtree: function (container, shouldObserve) {\nif (nativeShadow) {\nreturn;\n}\nvar self = this;\nvar scopify = function (node) {\nif (node.nodeType === Node.ELEMENT_NODE) {\nvar className = node.getAttribute('class');\nnode.setAttribute('class', self._scopeElementClass(node, className));\nvar n$ = node.querySelectorAll('*');\nfor (var i = 0, n; i < n$.length && (n = n$[i]); i++) {\nclassName = n.getAttribute('class');\nn.setAttribute('class', self._scopeElementClass(n, className));\n}\n}\n};\nscopify(container);\nif (shouldObserve) {\nvar mo = new MutationObserver(function (mxns) {\nfor (var i = 0, m; i < mxns.length && (m = mxns[i]); i++) {\nif (m.addedNodes) {\nfor (var j = 0; j < m.addedNodes.length; j++) {\nscopify(m.addedNodes[j]);\n}\n}\n}\n});\nmo.observe(container, {\nchildList: true,\nsubtree: true\n});\nreturn mo;\n}\n}\n});\n}());Polymer.StyleProperties = function () {\n'use strict';\nvar matchesSelector = Polymer.DomApi.matchesSelector;\nvar styleUtil = Polymer.StyleUtil;\nvar styleTransformer = Polymer.StyleTransformer;\nvar IS_IE = navigator.userAgent.match('Trident');\nvar settings = Polymer.Settings;\nreturn {\ndecorateStyles: function (styles, scope) {\nvar self = this, props = {}, keyframes = [], ruleIndex = 0;\nvar scopeSelector = styleTransformer._calcHostScope(scope.is, scope.extends);\nstyleUtil.forRulesInStyles(styles, function (rule, style) {\nself.decorateRule(rule);\nrule.index = ruleIndex++;\nself.whenHostOrRootRule(scope, rule, style, function (info) {\nif (rule.parent.type === styleUtil.ruleTypes.MEDIA_RULE) {\nscope.__notStyleScopeCacheable = true;\n}\nif (info.isHost) {\nvar hostContextOrFunction = info.selector.split(' ').some(function (s) {\nreturn s.indexOf(scopeSelector) === 0 && s.length !== scopeSelector.length;\n});\nscope.__notStyleScopeCacheable = scope.__notStyleScopeCacheable || hostContextOrFunction;\n}\n});\nself.collectPropertiesInCssText(rule.propertyInfo.cssText, props);\n}, function onKeyframesRule(rule) {\nkeyframes.push(rule);\n});\nstyles._keyframes = keyframes;\nvar names = [];\nfor (var i in props) {\nnames.push(i);\n}\nreturn names;\n},\ndecorateRule: function (rule) {\nif (rule.propertyInfo) {\nreturn rule.propertyInfo;\n}\nvar info = {}, properties = {};\nvar hasProperties = this.collectProperties(rule, properties);\nif (hasProperties) {\ninfo.properties = properties;\nrule.rules = null;\n}\ninfo.cssText = this.collectCssText(rule);\nrule.propertyInfo = info;\nreturn info;\n},\ncollectProperties: function (rule, properties) {\nvar info = rule.propertyInfo;\nif (info) {\nif (info.properties) {\nPolymer.Base.mixin(properties, info.properties);\nreturn true;\n}\n} else {\nvar m, rx = this.rx.VAR_ASSIGN;\nvar cssText = rule.parsedCssText;\nvar value;\nvar any;\nwhile (m = rx.exec(cssText)) {\nvalue = (m[2] || m[3]).trim();\nif (value !== 'inherit') {\nproperties[m[1].trim()] = value;\n}\nany = true;\n}\nreturn any;\n}\n},\ncollectCssText: function (rule) {\nreturn this.collectConsumingCssText(rule.parsedCssText);\n},\ncollectConsumingCssText: function (cssText) {\nreturn cssText.replace(this.rx.BRACKETED, '').replace(this.rx.VAR_ASSIGN, '');\n},\ncollectPropertiesInCssText: function (cssText, props) {\nvar m;\nwhile (m = this.rx.VAR_CONSUMED.exec(cssText)) {\nvar name = m[1];\nif (m[2] !== ':') {\nprops[name] = true;\n}\n}\n},\nreify: function (props) {\nvar names = Object.getOwnPropertyNames(props);\nfor (var i = 0, n; i < names.length; i++) {\nn = names[i];\nprops[n] = this.valueForProperty(props[n], props);\n}\n},\nvalueForProperty: function (property, props) {\nif (property) {\nif (property.indexOf(';') >= 0) {\nproperty = this.valueForProperties(property, props);\n} else {\nvar self = this;\nvar fn = function (prefix, value, fallback, suffix) {\nvar propertyValue = self.valueForProperty(props[value], props);\nif (!propertyValue || propertyValue === 'initial') {\npropertyValue = self.valueForProperty(props[fallback] || fallback, props) || fallback;\n} else if (propertyValue === 'apply-shim-inherit') {\npropertyValue = 'inherit';\n}\nreturn prefix + (propertyValue || '') + suffix;\n};\nproperty = styleUtil.processVariableAndFallback(property, fn);\n}\n}\nreturn property && property.trim() || '';\n},\nvalueForProperties: function (property, props) {\nvar parts = property.split(';');\nfor (var i = 0, p, m; i < parts.length; i++) {\nif (p = parts[i]) {\nthis.rx.MIXIN_MATCH.lastIndex = 0;\nm = this.rx.MIXIN_MATCH.exec(p);\nif (m) {\np = this.valueForProperty(props[m[1]], props);\n} else {\nvar colon = p.indexOf(':');\nif (colon !== -1) {\nvar pp = p.substring(colon);\npp = pp.trim();\npp = this.valueForProperty(pp, props) || pp;\np = p.substring(0, colon) + pp;\n}\n}\nparts[i] = p && p.lastIndexOf(';') === p.length - 1 ? p.slice(0, -1) : p || '';\n}\n}\nreturn parts.join(';');\n},\napplyProperties: function (rule, props) {\nvar output = '';\nif (!rule.propertyInfo) {\nthis.decorateRule(rule);\n}\nif (rule.propertyInfo.cssText) {\noutput = this.valueForProperties(rule.propertyInfo.cssText, props);\n}\nrule.cssText = output;\n},\napplyKeyframeTransforms: function (rule, keyframeTransforms) {\nvar input = rule.cssText;\nvar output = rule.cssText;\nif (rule.hasAnimations == null) {\nrule.hasAnimations = this.rx.ANIMATION_MATCH.test(input);\n}\nif (rule.hasAnimations) {\nvar transform;\nif (rule.keyframeNamesToTransform == null) {\nrule.keyframeNamesToTransform = [];\nfor (var keyframe in keyframeTransforms) {\ntransform = keyframeTransforms[keyframe];\noutput = transform(input);\nif (input !== output) {\ninput = output;\nrule.keyframeNamesToTransform.push(keyframe);\n}\n}\n} else {\nfor (var i = 0; i < rule.keyframeNamesToTransform.length; ++i) {\ntransform = keyframeTransforms[rule.keyframeNamesToTransform[i]];\ninput = transform(input);\n}\noutput = input;\n}\n}\nrule.cssText = output;\n},\npropertyDataFromStyles: function (styles, element) {\nvar props = {}, self = this;\nvar o = [];\nstyleUtil.forActiveRulesInStyles(styles, function (rule) {\nif (!rule.propertyInfo) {\nself.decorateRule(rule);\n}\nvar selectorToMatch = rule.transformedSelector || rule.parsedSelector;\nif (element && rule.propertyInfo.properties && selectorToMatch) {\nif (matchesSelector.call(element, selectorToMatch)) {\nself.collectProperties(rule, props);\naddToBitMask(rule.index, o);\n}\n}\n});\nreturn {\nproperties: props,\nkey: o\n};\n},\nwhenHostOrRootRule: function (scope, rule, style, callback) {\nif (!rule.propertyInfo) {\nself.decorateRule(rule);\n}\nif (!rule.propertyInfo.properties) {\nreturn;\n}\nvar hostScope = scope.is ? styleTransformer._calcHostScope(scope.is, scope.extends) : 'html';\nvar parsedSelector = rule.parsedSelector;\nvar isRoot = parsedSelector === ':root';\nvar isHost = parsedSelector.indexOf(':host') === 0;\nvar cssBuild = scope.__cssBuild || style.__cssBuild;\nif (cssBuild === 'shady') {\nisRoot = parsedSelector === hostScope + ' > *.' + hostScope || parsedSelector.indexOf('html') !== -1;\nisHost = !isRoot && parsedSelector.indexOf(hostScope) === 0;\n}\nif (cssBuild === 'shadow') {\nisRoot = parsedSelector === ':host > *' || parsedSelector === 'html';\nisHost = isHost && !isRoot;\n}\nif (!isRoot && !isHost) {\nreturn;\n}\nvar selectorToMatch = hostScope;\nif (isHost) {\nif (settings.useNativeShadow && !rule.transformedSelector) {\nrule.transformedSelector = styleTransformer._transformRuleCss(rule, styleTransformer._transformComplexSelector, scope.is, hostScope);\n}\nselectorToMatch = rule.transformedSelector || rule.parsedSelector;\n}\ncallback({\nselector: selectorToMatch,\nisHost: isHost,\nisRoot: isRoot\n});\n},\nhostAndRootPropertiesForScope: function (scope) {\nvar hostProps = {}, rootProps = {}, self = this;\nstyleUtil.forActiveRulesInStyles(scope._styles, function (rule, style) {\nself.whenHostOrRootRule(scope, rule, style, function (info) {\nvar element = scope._element || scope;\nif (matchesSelector.call(element, info.selector)) {\nif (info.isHost) {\nself.collectProperties(rule, hostProps);\n} else {\nself.collectProperties(rule, rootProps);\n}\n}\n});\n});\nreturn {\nrootProps: rootProps,\nhostProps: hostProps\n};\n},\ntransformStyles: function (element, properties, scopeSelector) {\nvar self = this;\nvar hostSelector = styleTransformer._calcHostScope(element.is, element.extends);\nvar rxHostSelector = element.extends ? '\\\\' + hostSelector.slice(0, -1) + '\\\\]' : hostSelector;\nvar hostRx = new RegExp(this.rx.HOST_PREFIX + rxHostSelector + this.rx.HOST_SUFFIX);\nvar keyframeTransforms = this._elementKeyframeTransforms(element, scopeSelector);\nreturn styleTransformer.elementStyles(element, function (rule) {\nself.applyProperties(rule, properties);\nif (!settings.useNativeShadow && !Polymer.StyleUtil.isKeyframesSelector(rule) && rule.cssText) {\nself.applyKeyframeTransforms(rule, keyframeTransforms);\nself._scopeSelector(rule, hostRx, hostSelector, element._scopeCssViaAttr, scopeSelector);\n}\n});\n},\n_elementKeyframeTransforms: function (element, scopeSelector) {\nvar keyframesRules = element._styles._keyframes;\nvar keyframeTransforms = {};\nif (!settings.useNativeShadow && keyframesRules) {\nfor (var i = 0, keyframesRule = keyframesRules[i]; i < keyframesRules.length; keyframesRule = keyframesRules[++i]) {\nthis._scopeKeyframes(keyframesRule, scopeSelector);\nkeyframeTransforms[keyframesRule.keyframesName] = this._keyframesRuleTransformer(keyframesRule);\n}\n}\nreturn keyframeTransforms;\n},\n_keyframesRuleTransformer: function (keyframesRule) {\nreturn function (cssText) {\nreturn cssText.replace(keyframesRule.keyframesNameRx, keyframesRule.transformedKeyframesName);\n};\n},\n_scopeKeyframes: function (rule, scopeId) {\nrule.keyframesNameRx = new RegExp(rule.keyframesName, 'g');\nrule.transformedKeyframesName = rule.keyframesName + '-' + scopeId;\nrule.transformedSelector = rule.transformedSelector || rule.selector;\nrule.selector = rule.transformedSelector.replace(rule.keyframesName, rule.transformedKeyframesName);\n},\n_scopeSelector: function (rule, hostRx, hostSelector, viaAttr, scopeId) {\nrule.transformedSelector = rule.transformedSelector || rule.selector;\nvar selector = rule.transformedSelector;\nvar scope = viaAttr ? '[' + styleTransformer.SCOPE_NAME + '~=' + scopeId + ']' : '.' + scopeId;\nvar parts = selector.split(',');\nfor (var i = 0, l = parts.length, p; i < l && (p = parts[i]); i++) {\nparts[i] = p.match(hostRx) ? p.replace(hostSelector, scope) : scope + ' ' + p;\n}\nrule.selector = parts.join(',');\n},\napplyElementScopeSelector: function (element, selector, old, viaAttr) {\nvar c = viaAttr ? element.getAttribute(styleTransformer.SCOPE_NAME) : element.getAttribute('class') || '';\nvar v = old ? c.replace(old, selector) : (c ? c + ' ' : '') + this.XSCOPE_NAME + ' ' + selector;\nif (c !== v) {\nif (viaAttr) {\nelement.setAttribute(styleTransformer.SCOPE_NAME, v);\n} else {\nelement.setAttribute('class', v);\n}\n}\n},\napplyElementStyle: function (element, properties, selector, style) {\nvar cssText = style ? style.textContent || '' : this.transformStyles(element, properties, selector);\nvar s = element._customStyle;\nif (s && !settings.useNativeShadow && s !== style) {\ns._useCount--;\nif (s._useCount <= 0 && s.parentNode) {\ns.parentNode.removeChild(s);\n}\n}\nif (settings.useNativeShadow) {\nif (element._customStyle) {\nelement._customStyle.textContent = cssText;\nstyle = element._customStyle;\n} else if (cssText) {\nstyle = styleUtil.applyCss(cssText, selector, element.root, element._scopeStyle);\n}\n} else {\nif (!style) {\nif (cssText) {\nstyle = styleUtil.applyCss(cssText, selector, null, element._scopeStyle);\n}\n} else if (!style.parentNode) {\nstyleUtil.applyStyle(style, null, element._scopeStyle);\n}\n}\nif (style) {\nstyle._useCount = style._useCount || 0;\nif (element._customStyle != style) {\nstyle._useCount++;\n}\nelement._customStyle = style;\n}\nif (IS_IE) {\nstyle.textContent = style.textContent;\n}\nreturn style;\n},\nmixinCustomStyle: function (props, customStyle) {\nvar v;\nfor (var i in customStyle) {\nv = customStyle[i];\nif (v || v === 0) {\nprops[i] = v;\n}\n}\n},\nupdateNativeStyleProperties: function (element, properties) {\nvar oldPropertyNames = element.__customStyleProperties;\nif (oldPropertyNames) {\nfor (var i = 0; i < oldPropertyNames.length; i++) {\nelement.style.removeProperty(oldPropertyNames[i]);\n}\n}\nvar propertyNames = [];\nfor (var p in properties) {\nif (properties[p] !== null) {\nelement.style.setProperty(p, properties[p]);\npropertyNames.push(p);\n}\n}\nelement.__customStyleProperties = propertyNames;\n},\nrx: styleUtil.rx,\nXSCOPE_NAME: 'x-scope'\n};\nfunction addToBitMask(n, bits) {\nvar o = parseInt(n / 32);\nvar v = 1 << n % 32;\nbits[o] = (bits[o] || 0) | v;\n}\n}();(function () {\nPolymer.StyleCache = function () {\nthis.cache = {};\n};\nPolymer.StyleCache.prototype = {\nMAX: 100,\nstore: function (is, data, keyValues, keyStyles) {\ndata.keyValues = keyValues;\ndata.styles = keyStyles;\nvar s$ = this.cache[is] = this.cache[is] || [];\ns$.push(data);\nif (s$.length > this.MAX) {\ns$.shift();\n}\n},\nretrieve: function (is, keyValues, keyStyles) {\nvar cache = this.cache[is];\nif (cache) {\nfor (var i = cache.length - 1, data; i >= 0; i--) {\ndata = cache[i];\nif (keyStyles === data.styles && this._objectsEqual(keyValues, data.keyValues)) {\nreturn data;\n}\n}\n}\n},\nclear: function () {\nthis.cache = {};\n},\n_objectsEqual: function (target, source) {\nvar t, s;\nfor (var i in target) {\nt = target[i], s = source[i];\nif (!(typeof t === 'object' && t ? this._objectsStrictlyEqual(t, s) : t === s)) {\nreturn false;\n}\n}\nif (Array.isArray(target)) {\nreturn target.length === source.length;\n}\nreturn true;\n},\n_objectsStrictlyEqual: function (target, source) {\nreturn this._objectsEqual(target, source) && this._objectsEqual(source, target);\n}\n};\n}());Polymer.StyleDefaults = function () {\nvar styleProperties = Polymer.StyleProperties;\nvar StyleCache = Polymer.StyleCache;\nvar nativeVariables = Polymer.Settings.useNativeCSSProperties;\nvar api = {\n_styles: [],\n_properties: null,\ncustomStyle: {},\n_styleCache: new StyleCache(),\n_element: Polymer.DomApi.wrap(document.documentElement),\naddStyle: function (style) {\nthis._styles.push(style);\nthis._properties = null;\n},\nget _styleProperties() {\nif (!this._properties) {\nstyleProperties.decorateStyles(this._styles, this);\nthis._styles._scopeStyleProperties = null;\nthis._properties = styleProperties.hostAndRootPropertiesForScope(this).rootProps;\nstyleProperties.mixinCustomStyle(this._properties, this.customStyle);\nstyleProperties.reify(this._properties);\n}\nreturn this._properties;\n},\nhasStyleProperties: function () {\nreturn Boolean(this._properties);\n},\n_needsStyleProperties: function () {\n},\n_computeStyleProperties: function () {\nreturn this._styleProperties;\n},\nupdateStyles: function (properties) {\nthis._properties = null;\nif (properties) {\nPolymer.Base.mixin(this.customStyle, properties);\n}\nthis._styleCache.clear();\nfor (var i = 0, s; i < this._styles.length; i++) {\ns = this._styles[i];\ns = s.__importElement || s;\ns._apply();\n}\nif (nativeVariables) {\nstyleProperties.updateNativeStyleProperties(document.documentElement, this.customStyle);\n}\n}\n};\nreturn api;\n}();(function () {\n'use strict';\nvar serializeValueToAttribute = Polymer.Base.serializeValueToAttribute;\nvar propertyUtils = Polymer.StyleProperties;\nvar styleTransformer = Polymer.StyleTransformer;\nvar styleDefaults = Polymer.StyleDefaults;\nvar nativeShadow = Polymer.Settings.useNativeShadow;\nvar nativeVariables = Polymer.Settings.useNativeCSSProperties;\nPolymer.Base._addFeature({\n_prepStyleProperties: function () {\nif (!nativeVariables) {\nthis._ownStylePropertyNames = this._styles && this._styles.length ? propertyUtils.decorateStyles(this._styles, this) : null;\n}\n},\ncustomStyle: null,\ngetComputedStyleValue: function (property) {\nreturn !nativeVariables && this._styleProperties && this._styleProperties[property] || getComputedStyle(this).getPropertyValue(property);\n},\n_setupStyleProperties: function () {\nthis.customStyle = {};\nthis._styleCache = null;\nthis._styleProperties = null;\nthis._scopeSelector = null;\nthis._ownStyleProperties = null;\nthis._customStyle = null;\n},\n_needsStyleProperties: function () {\nreturn Boolean(!nativeVariables && this._ownStylePropertyNames && this._ownStylePropertyNames.length);\n},\n_validateApplyShim: function () {\nif (this.__applyShimInvalid) {\nPolymer.ApplyShim.transform(this._styles, this.__proto__);\nvar cssText = styleTransformer.elementStyles(this);\nif (nativeShadow) {\nvar templateStyle = this._template.content.querySelector('style');\nif (templateStyle) {\ntemplateStyle.textContent = cssText;\n}\n} else {\nvar shadyStyle = this._scopeStyle && this._scopeStyle.nextSibling;\nif (shadyStyle) {\nshadyStyle.textContent = cssText;\n}\n}\n}\n},\n_beforeAttached: function () {\nif ((!this._scopeSelector || this.__stylePropertiesInvalid) && this._needsStyleProperties()) {\nthis.__stylePropertiesInvalid = false;\nthis._updateStyleProperties();\n}\n},\n_findStyleHost: function () {\nvar e = this, root;\nwhile (root = Polymer.dom(e).getOwnerRoot()) {\nif (Polymer.isInstance(root.host)) {\nreturn root.host;\n}\ne = root.host;\n}\nreturn styleDefaults;\n},\n_updateStyleProperties: function () {\nvar info, scope = this._findStyleHost();\nif (!scope._styleProperties) {\nscope._computeStyleProperties();\n}\nif (!scope._styleCache) {\nscope._styleCache = new Polymer.StyleCache();\n}\nvar scopeData = propertyUtils.propertyDataFromStyles(scope._styles, this);\nvar scopeCacheable = !this.__notStyleScopeCacheable;\nif (scopeCacheable) {\nscopeData.key.customStyle = this.customStyle;\ninfo = scope._styleCache.retrieve(this.is, scopeData.key, this._styles);\n}\nvar scopeCached = Boolean(info);\nif (scopeCached) {\nthis._styleProperties = info._styleProperties;\n} else {\nthis._computeStyleProperties(scopeData.properties);\n}\nthis._computeOwnStyleProperties();\nif (!scopeCached) {\ninfo = styleCache.retrieve(this.is, this._ownStyleProperties, this._styles);\n}\nvar globalCached = Boolean(info) && !scopeCached;\nvar style = this._applyStyleProperties(info);\nif (!scopeCached) {\nstyle = style && nativeShadow ? style.cloneNode(true) : style;\ninfo = {\nstyle: style,\n_scopeSelector: this._scopeSelector,\n_styleProperties: this._styleProperties\n};\nif (scopeCacheable) {\nscopeData.key.customStyle = {};\nthis.mixin(scopeData.key.customStyle, this.customStyle);\nscope._styleCache.store(this.is, info, scopeData.key, this._styles);\n}\nif (!globalCached) {\nstyleCache.store(this.is, Object.create(info), this._ownStyleProperties, this._styles);\n}\n}\n},\n_computeStyleProperties: function (scopeProps) {\nvar scope = this._findStyleHost();\nif (!scope._styleProperties) {\nscope._computeStyleProperties();\n}\nvar props = Object.create(scope._styleProperties);\nvar hostAndRootProps = propertyUtils.hostAndRootPropertiesForScope(this);\nthis.mixin(props, hostAndRootProps.hostProps);\nscopeProps = scopeProps || propertyUtils.propertyDataFromStyles(scope._styles, this).properties;\nthis.mixin(props, scopeProps);\nthis.mixin(props, hostAndRootProps.rootProps);\npropertyUtils.mixinCustomStyle(props, this.customStyle);\npropertyUtils.reify(props);\nthis._styleProperties = props;\n},\n_computeOwnStyleProperties: function () {\nvar props = {};\nfor (var i = 0, n; i < this._ownStylePropertyNames.length; i++) {\nn = this._ownStylePropertyNames[i];\nprops[n] = this._styleProperties[n];\n}\nthis._ownStyleProperties = props;\n},\n_scopeCount: 0,\n_applyStyleProperties: function (info) {\nvar oldScopeSelector = this._scopeSelector;\nthis._scopeSelector = info ? info._scopeSelector : this.is + '-' + this.__proto__._scopeCount++;\nvar style = propertyUtils.applyElementStyle(this, this._styleProperties, this._scopeSelector, info && info.style);\nif (!nativeShadow) {\npropertyUtils.applyElementScopeSelector(this, this._scopeSelector, oldScopeSelector, this._scopeCssViaAttr);\n}\nreturn style;\n},\nserializeValueToAttribute: function (value, attribute, node) {\nnode = node || this;\nif (attribute === 'class' && !nativeShadow) {\nvar host = node === this ? this.domHost || this.dataHost : this;\nif (host) {\nvalue = host._scopeElementClass(node, value);\n}\n}\nnode = this.shadyRoot && this.shadyRoot._hasDistributed ? Polymer.dom(node) : node;\nserializeValueToAttribute.call(this, value, attribute, node);\n},\n_scopeElementClass: function (element, selector) {\nif (!nativeShadow && !this._scopeCssViaAttr) {\nselector = (selector ? selector + ' ' : '') + SCOPE_NAME + ' ' + this.is + (element._scopeSelector ? ' ' + XSCOPE_NAME + ' ' + element._scopeSelector : '');\n}\nreturn selector;\n},\nupdateStyles: function (properties) {\nif (properties) {\nthis.mixin(this.customStyle, properties);\n}\nif (nativeVariables) {\npropertyUtils.updateNativeStyleProperties(this, this.customStyle);\n} else {\nif (this.isAttached) {\nif (this._needsStyleProperties()) {\nthis._updateStyleProperties();\n} else {\nthis._styleProperties = null;\n}\n} else {\nthis.__stylePropertiesInvalid = true;\n}\nif (this._styleCache) {\nthis._styleCache.clear();\n}\nthis._updateRootStyles();\n}\n},\n_updateRootStyles: function (root) {\nroot = root || this.root;\nvar c$ = Polymer.dom(root)._query(function (e) {\nreturn e.shadyRoot || e.shadowRoot;\n});\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nif (c.updateStyles) {\nc.updateStyles();\n}\n}\n}\n});\nPolymer.updateStyles = function (properties) {\nstyleDefaults.updateStyles(properties);\nPolymer.Base._updateRootStyles(document);\n};\nvar styleCache = new Polymer.StyleCache();\nPolymer.customStyleCache = styleCache;\nvar SCOPE_NAME = styleTransformer.SCOPE_NAME;\nvar XSCOPE_NAME = propertyUtils.XSCOPE_NAME;\n}());Polymer.Base._addFeature({\n_registerFeatures: function () {\nthis._prepIs();\nthis._prepConstructor();\nthis._prepStyles();\n},\n_finishRegisterFeatures: function () {\nthis._prepTemplate();\nthis._prepShimStyles();\nthis._prepAnnotations();\nthis._prepEffects();\nthis._prepBehaviors();\nthis._prepPropertyInfo();\nthis._prepBindings();\nthis._prepShady();\n},\n_prepBehavior: function (b) {\nthis._addPropertyEffects(b.properties);\nthis._addComplexObserverEffects(b.observers);\nthis._addHostAttributes(b.hostAttributes);\n},\n_initFeatures: function () {\nthis._setupGestures();\nthis._setupConfigure();\nthis._setupStyleProperties();\nthis._setupDebouncers();\nthis._setupShady();\nthis._registerHost();\nif (this._template) {\nthis._validateApplyShim();\nthis._poolContent();\nthis._beginHosting();\nthis._stampTemplate();\nthis._endHosting();\nthis._marshalAnnotationReferences();\n}\nthis._marshalInstanceEffects();\nthis._marshalBehaviors();\nthis._marshalHostAttributes();\nthis._marshalAttributes();\nthis._tryReady();\n},\n_marshalBehavior: function (b) {\nif (b.listeners) {\nthis._listenListeners(b.listeners);\n}\n}\n});(function () {\nvar propertyUtils = Polymer.StyleProperties;\nvar styleUtil = Polymer.StyleUtil;\nvar cssParse = Polymer.CssParse;\nvar styleDefaults = Polymer.StyleDefaults;\nvar styleTransformer = Polymer.StyleTransformer;\nvar applyShim = Polymer.ApplyShim;\nvar debounce = Polymer.Debounce;\nvar settings = Polymer.Settings;\nvar updateDebouncer;\nPolymer({\nis: 'custom-style',\nextends: 'style',\n_template: null,\nproperties: { include: String },\nready: function () {\nthis.__appliedElement = this.__appliedElement || this;\nthis.__cssBuild = styleUtil.getCssBuildType(this);\nif (this.__appliedElement !== this) {\nthis.__appliedElement.__cssBuild = this.__cssBuild;\n}\nthis._tryApply();\n},\nattached: function () {\nthis._tryApply();\n},\n_tryApply: function () {\nif (!this._appliesToDocument) {\nif (this.parentNode && this.parentNode.localName !== 'dom-module') {\nthis._appliesToDocument = true;\nvar e = this.__appliedElement;\nif (!settings.useNativeCSSProperties) {\nthis.__needsUpdateStyles = styleDefaults.hasStyleProperties();\nstyleDefaults.addStyle(e);\n}\nif (e.textContent || this.include) {\nthis._apply(true);\n} else {\nvar self = this;\nvar observer = new MutationObserver(function () {\nobserver.disconnect();\nself._apply(true);\n});\nobserver.observe(e, { childList: true });\n}\n}\n}\n},\n_updateStyles: function () {\nPolymer.updateStyles();\n},\n_apply: function (initialApply) {\nvar e = this.__appliedElement;\nif (this.include) {\ne.textContent = styleUtil.cssFromModules(this.include, true) + e.textContent;\n}\nif (!e.textContent) {\nreturn;\n}\nvar buildType = this.__cssBuild;\nvar targetedBuild = styleUtil.isTargetedBuild(buildType);\nif (settings.useNativeCSSProperties && targetedBuild) {\nreturn;\n}\nvar styleRules = styleUtil.rulesForStyle(e);\nif (!targetedBuild) {\nstyleUtil.forEachRule(styleRules, function (rule) {\nstyleTransformer.documentRule(rule);\nif (settings.useNativeCSSProperties && !buildType) {\napplyShim.transformRule(rule);\n}\n});\n}\nif (settings.useNativeCSSProperties) {\ne.textContent = styleUtil.toCssText(styleRules);\n} else {\nvar self = this;\nvar fn = function fn() {\nself._flushCustomProperties();\n};\nif (initialApply) {\nPolymer.RenderStatus.whenReady(fn);\n} else {\nfn();\n}\n}\n},\n_flushCustomProperties: function () {\nif (this.__needsUpdateStyles) {\nthis.__needsUpdateStyles = false;\nupdateDebouncer = debounce(updateDebouncer, this._updateStyles);\n} else {\nthis._applyCustomProperties();\n}\n},\n_applyCustomProperties: function () {\nvar element = this.__appliedElement;\nthis._computeStyleProperties();\nvar props = this._styleProperties;\nvar rules = styleUtil.rulesForStyle(element);\nif (!rules) {\nreturn;\n}\nelement.textContent = styleUtil.toCssText(rules, function (rule) {\nvar css = rule.cssText = rule.parsedCssText;\nif (rule.propertyInfo && rule.propertyInfo.cssText) {\ncss = cssParse.removeCustomPropAssignment(css);\nrule.cssText = propertyUtils.valueForProperties(css, props);\n}\n});\n}\n});\n}());Polymer.Templatizer = {\nproperties: { __hideTemplateChildren__: { observer: '_showHideChildren' } },\n_instanceProps: Polymer.nob,\n_parentPropPrefix: '_parent_',\ntemplatize: function (template) {\nthis._templatized = template;\nif (!template._content) {\ntemplate._content = template.content;\n}\nif (template._content._ctor) {\nthis.ctor = template._content._ctor;\nthis._prepParentProperties(this.ctor.prototype, template);\nreturn;\n}\nvar archetype = Object.create(Polymer.Base);\nthis._customPrepAnnotations(archetype, template);\nthis._prepParentProperties(archetype, template);\narchetype._prepEffects();\nthis._customPrepEffects(archetype);\narchetype._prepBehaviors();\narchetype._prepPropertyInfo();\narchetype._prepBindings();\narchetype._notifyPathUp = this._notifyPathUpImpl;\narchetype._scopeElementClass = this._scopeElementClassImpl;\narchetype.listen = this._listenImpl;\narchetype._showHideChildren = this._showHideChildrenImpl;\narchetype.__setPropertyOrig = this.__setProperty;\narchetype.__setProperty = this.__setPropertyImpl;\nvar _constructor = this._constructorImpl;\nvar ctor = function TemplateInstance(model, host) {\n_constructor.call(this, model, host);\n};\nctor.prototype = archetype;\narchetype.constructor = ctor;\ntemplate._content._ctor = ctor;\nthis.ctor = ctor;\n},\n_getRootDataHost: function () {\nreturn this.dataHost && this.dataHost._rootDataHost || this.dataHost;\n},\n_showHideChildrenImpl: function (hide) {\nvar c = this._children;\nfor (var i = 0; i < c.length; i++) {\nvar n = c[i];\nif (Boolean(hide) != Boolean(n.__hideTemplateChildren__)) {\nif (n.nodeType === Node.TEXT_NODE) {\nif (hide) {\nn.__polymerTextContent__ = n.textContent;\nn.textContent = '';\n} else {\nn.textContent = n.__polymerTextContent__;\n}\n} else if (n.style) {\nif (hide) {\nn.__polymerDisplay__ = n.style.display;\nn.style.display = 'none';\n} else {\nn.style.display = n.__polymerDisplay__;\n}\n}\n}\nn.__hideTemplateChildren__ = hide;\n}\n},\n__setPropertyImpl: function (property, value, fromAbove, node) {\nif (node && node.__hideTemplateChildren__ && property == 'textContent') {\nproperty = '__polymerTextContent__';\n}\nthis.__setPropertyOrig(property, value, fromAbove, node);\n},\n_debounceTemplate: function (fn) {\nPolymer.dom.addDebouncer(this.debounce('_debounceTemplate', fn));\n},\n_flushTemplates: function () {\nPolymer.dom.flush();\n},\n_customPrepEffects: function (archetype) {\nvar parentProps = archetype._parentProps;\nfor (var prop in parentProps) {\narchetype._addPropertyEffect(prop, 'function', this._createHostPropEffector(prop));\n}\nfor (prop in this._instanceProps) {\narchetype._addPropertyEffect(prop, 'function', this._createInstancePropEffector(prop));\n}\n},\n_customPrepAnnotations: function (archetype, template) {\narchetype._template = template;\nvar c = template._content;\nif (!c._notes) {\nvar rootDataHost = archetype._rootDataHost;\nif (rootDataHost) {\nPolymer.Annotations.prepElement = function () {\nrootDataHost._prepElement();\n};\n}\nc._notes = Polymer.Annotations.parseAnnotations(template);\nPolymer.Annotations.prepElement = null;\nthis._processAnnotations(c._notes);\n}\narchetype._notes = c._notes;\narchetype._parentProps = c._parentProps;\n},\n_prepParentProperties: function (archetype, template) {\nvar parentProps = this._parentProps = archetype._parentProps;\nif (this._forwardParentProp && parentProps) {\nvar proto = archetype._parentPropProto;\nvar prop;\nif (!proto) {\nfor (prop in this._instanceProps) {\ndelete parentProps[prop];\n}\nproto = archetype._parentPropProto = Object.create(null);\nif (template != this) {\nPolymer.Bind.prepareModel(proto);\nPolymer.Base.prepareModelNotifyPath(proto);\n}\nfor (prop in parentProps) {\nvar parentProp = this._parentPropPrefix + prop;\nvar effects = [\n{\nkind: 'function',\neffect: this._createForwardPropEffector(prop),\nfn: Polymer.Bind._functionEffect\n},\n{\nkind: 'notify',\nfn: Polymer.Bind._notifyEffect,\neffect: { event: Polymer.CaseMap.camelToDashCase(parentProp) + '-changed' }\n}\n];\nPolymer.Bind._createAccessors(proto, parentProp, effects);\n}\n}\nvar self = this;\nif (template != this) {\nPolymer.Bind.prepareInstance(template);\ntemplate._forwardParentProp = function (source, value) {\nself._forwardParentProp(source, value);\n};\n}\nthis._extendTemplate(template, proto);\ntemplate._pathEffector = function (path, value, fromAbove) {\nreturn self._pathEffectorImpl(path, value, fromAbove);\n};\n}\n},\n_createForwardPropEffector: function (prop) {\nreturn function (source, value) {\nthis._forwardParentProp(prop, value);\n};\n},\n_createHostPropEffector: function (prop) {\nvar prefix = this._parentPropPrefix;\nreturn function (source, value) {\nthis.dataHost._templatized[prefix + prop] = value;\n};\n},\n_createInstancePropEffector: function (prop) {\nreturn function (source, value, old, fromAbove) {\nif (!fromAbove) {\nthis.dataHost._forwardInstanceProp(this, prop, value);\n}\n};\n},\n_extendTemplate: function (template, proto) {\nvar n$ = Object.getOwnPropertyNames(proto);\nif (proto._propertySetter) {\ntemplate._propertySetter = proto._propertySetter;\n}\nfor (var i = 0, n; i < n$.length && (n = n$[i]); i++) {\nvar val = template[n];\nvar pd = Object.getOwnPropertyDescriptor(proto, n);\nObject.defineProperty(template, n, pd);\nif (val !== undefined) {\ntemplate._propertySetter(n, val);\n}\n}\n},\n_showHideChildren: function (hidden) {\n},\n_forwardInstancePath: function (inst, path, value) {\n},\n_forwardInstanceProp: function (inst, prop, value) {\n},\n_notifyPathUpImpl: function (path, value) {\nvar dataHost = this.dataHost;\nvar dot = path.indexOf('.');\nvar root = dot < 0 ? path : path.slice(0, dot);\ndataHost._forwardInstancePath.call(dataHost, this, path, value);\nif (root in dataHost._parentProps) {\ndataHost._templatized._notifyPath(dataHost._parentPropPrefix + path, value);\n}\n},\n_pathEffectorImpl: function (path, value, fromAbove) {\nif (this._forwardParentPath) {\nif (path.indexOf(this._parentPropPrefix) === 0) {\nvar subPath = path.substring(this._parentPropPrefix.length);\nvar model = this._modelForPath(subPath);\nif (model in this._parentProps) {\nthis._forwardParentPath(subPath, value);\n}\n}\n}\nPolymer.Base._pathEffector.call(this._templatized, path, value, fromAbove);\n},\n_constructorImpl: function (model, host) {\nthis._rootDataHost = host._getRootDataHost();\nthis._setupConfigure(model);\nthis._registerHost(host);\nthis._beginHosting();\nthis.root = this.instanceTemplate(this._template);\nthis.root.__noContent = !this._notes._hasContent;\nthis.root.__styleScoped = true;\nthis._endHosting();\nthis._marshalAnnotatedNodes();\nthis._marshalInstanceEffects();\nthis._marshalAnnotatedListeners();\nvar children = [];\nfor (var n = this.root.firstChild; n; n = n.nextSibling) {\nchildren.push(n);\nn._templateInstance = this;\n}\nthis._children = children;\nif (host.__hideTemplateChildren__) {\nthis._showHideChildren(true);\n}\nthis._tryReady();\n},\n_listenImpl: function (node, eventName, methodName) {\nvar model = this;\nvar host = this._rootDataHost;\nvar handler = host._createEventHandler(node, eventName, methodName);\nvar decorated = function (e) {\ne.model = model;\nhandler(e);\n};\nhost._listen(node, eventName, decorated);\n},\n_scopeElementClassImpl: function (node, value) {\nvar host = this._rootDataHost;\nif (host) {\nreturn host._scopeElementClass(node, value);\n}\nreturn value;\n},\nstamp: function (model) {\nmodel = model || {};\nif (this._parentProps) {\nvar templatized = this._templatized;\nfor (var prop in this._parentProps) {\nif (model[prop] === undefined) {\nmodel[prop] = templatized[this._parentPropPrefix + prop];\n}\n}\n}\nreturn new this.ctor(model, this);\n},\nmodelForElement: function (el) {\nvar model;\nwhile (el) {\nif (model = el._templateInstance) {\nif (model.dataHost != this) {\nel = model.dataHost;\n} else {\nreturn model;\n}\n} else {\nel = el.parentNode;\n}\n}\n}\n};Polymer({\nis: 'dom-template',\nextends: 'template',\n_template: null,\nbehaviors: [Polymer.Templatizer],\nready: function () {\nthis.templatize(this);\n}\n});Polymer._collections = new WeakMap();\nPolymer.Collection = function (userArray) {\nPolymer._collections.set(userArray, this);\nthis.userArray = userArray;\nthis.store = userArray.slice();\nthis.initMap();\n};\nPolymer.Collection.prototype = {\nconstructor: Polymer.Collection,\ninitMap: function () {\nvar omap = this.omap = new WeakMap();\nvar pmap = this.pmap = {};\nvar s = this.store;\nfor (var i = 0; i < s.length; i++) {\nvar item = s[i];\nif (item && typeof item == 'object') {\nomap.set(item, i);\n} else {\npmap[item] = i;\n}\n}\n},\nadd: function (item) {\nvar key = this.store.push(item) - 1;\nif (item && typeof item == 'object') {\nthis.omap.set(item, key);\n} else {\nthis.pmap[item] = key;\n}\nreturn '#' + key;\n},\nremoveKey: function (key) {\nif (key = this._parseKey(key)) {\nthis._removeFromMap(this.store[key]);\ndelete this.store[key];\n}\n},\n_removeFromMap: function (item) {\nif (item && typeof item == 'object') {\nthis.omap.delete(item);\n} else {\ndelete this.pmap[item];\n}\n},\nremove: function (item) {\nvar key = this.getKey(item);\nthis.removeKey(key);\nreturn key;\n},\ngetKey: function (item) {\nvar key;\nif (item && typeof item == 'object') {\nkey = this.omap.get(item);\n} else {\nkey = this.pmap[item];\n}\nif (key != undefined) {\nreturn '#' + key;\n}\n},\ngetKeys: function () {\nreturn Object.keys(this.store).map(function (key) {\nreturn '#' + key;\n});\n},\n_parseKey: function (key) {\nif (key && key[0] == '#') {\nreturn key.slice(1);\n}\n},\nsetItem: function (key, item) {\nif (key = this._parseKey(key)) {\nvar old = this.store[key];\nif (old) {\nthis._removeFromMap(old);\n}\nif (item && typeof item == 'object') {\nthis.omap.set(item, key);\n} else {\nthis.pmap[item] = key;\n}\nthis.store[key] = item;\n}\n},\ngetItem: function (key) {\nif (key = this._parseKey(key)) {\nreturn this.store[key];\n}\n},\ngetItems: function () {\nvar items = [], store = this.store;\nfor (var key in store) {\nitems.push(store[key]);\n}\nreturn items;\n},\n_applySplices: function (splices) {\nvar keyMap = {}, key;\nfor (var i = 0, s; i < splices.length && (s = splices[i]); i++) {\ns.addedKeys = [];\nfor (var j = 0; j < s.removed.length; j++) {\nkey = this.getKey(s.removed[j]);\nkeyMap[key] = keyMap[key] ? null : -1;\n}\nfor (j = 0; j < s.addedCount; j++) {\nvar item = this.userArray[s.index + j];\nkey = this.getKey(item);\nkey = key === undefined ? this.add(item) : key;\nkeyMap[key] = keyMap[key] ? null : 1;\ns.addedKeys.push(key);\n}\n}\nvar removed = [];\nvar added = [];\nfor (key in keyMap) {\nif (keyMap[key] < 0) {\nthis.removeKey(key);\nremoved.push(key);\n}\nif (keyMap[key] > 0) {\nadded.push(key);\n}\n}\nreturn [{\nremoved: removed,\nadded: added\n}];\n}\n};\nPolymer.Collection.get = function (userArray) {\nreturn Polymer._collections.get(userArray) || new Polymer.Collection(userArray);\n};\nPolymer.Collection.applySplices = function (userArray, splices) {\nvar coll = Polymer._collections.get(userArray);\nreturn coll ? coll._applySplices(splices) : null;\n};Polymer({\nis: 'dom-repeat',\nextends: 'template',\n_template: null,\nproperties: {\nitems: { type: Array },\nas: {\ntype: String,\nvalue: 'item'\n},\nindexAs: {\ntype: String,\nvalue: 'index'\n},\nsort: {\ntype: Function,\nobserver: '_sortChanged'\n},\nfilter: {\ntype: Function,\nobserver: '_filterChanged'\n},\nobserve: {\ntype: String,\nobserver: '_observeChanged'\n},\ndelay: Number,\nrenderedItemCount: {\ntype: Number,\nnotify: true,\nreadOnly: true\n},\ninitialCount: {\ntype: Number,\nobserver: '_initializeChunking'\n},\ntargetFramerate: {\ntype: Number,\nvalue: 20\n},\n_targetFrameTime: {\ntype: Number,\ncomputed: '_computeFrameTime(targetFramerate)'\n}\n},\nbehaviors: [Polymer.Templatizer],\nobservers: ['_itemsChanged(items.*)'],\ncreated: function () {\nthis._instances = [];\nthis._pool = [];\nthis._limit = Infinity;\nvar self = this;\nthis._boundRenderChunk = function () {\nself._renderChunk();\n};\n},\ndetached: function () {\nthis.__isDetached = true;\nfor (var i = 0; i < this._instances.length; i++) {\nthis._detachInstance(i);\n}\n},\nattached: function () {\nif (this.__isDetached) {\nthis.__isDetached = false;\nvar parent = Polymer.dom(Polymer.dom(this).parentNode);\nfor (var i = 0; i < this._instances.length; i++) {\nthis._attachInstance(i, parent);\n}\n}\n},\nready: function () {\nthis._instanceProps = { __key__: true };\nthis._instanceProps[this.as] = true;\nthis._instanceProps[this.indexAs] = true;\nif (!this.ctor) {\nthis.templatize(this);\n}\n},\n_sortChanged: function (sort) {\nvar dataHost = this._getRootDataHost();\nthis._sortFn = sort && (typeof sort == 'function' ? sort : function () {\nreturn dataHost[sort].apply(dataHost, arguments);\n});\nthis._needFullRefresh = true;\nif (this.items) {\nthis._debounceTemplate(this._render);\n}\n},\n_filterChanged: function (filter) {\nvar dataHost = this._getRootDataHost();\nthis._filterFn = filter && (typeof filter == 'function' ? filter : function () {\nreturn dataHost[filter].apply(dataHost, arguments);\n});\nthis._needFullRefresh = true;\nif (this.items) {\nthis._debounceTemplate(this._render);\n}\n},\n_computeFrameTime: function (rate) {\nreturn Math.ceil(1000 / rate);\n},\n_initializeChunking: function () {\nif (this.initialCount) {\nthis._limit = this.initialCount;\nthis._chunkCount = this.initialCount;\nthis._lastChunkTime = performance.now();\n}\n},\n_tryRenderChunk: function () {\nif (this.items && this._limit < this.items.length) {\nthis.debounce('renderChunk', this._requestRenderChunk);\n}\n},\n_requestRenderChunk: function () {\nrequestAnimationFrame(this._boundRenderChunk);\n},\n_renderChunk: function () {\nvar currChunkTime = performance.now();\nvar ratio = this._targetFrameTime / (currChunkTime - this._lastChunkTime);\nthis._chunkCount = Math.round(this._chunkCount * ratio) || 1;\nthis._limit += this._chunkCount;\nthis._lastChunkTime = currChunkTime;\nthis._debounceTemplate(this._render);\n},\n_observeChanged: function () {\nthis._observePaths = this.observe && this.observe.replace('.*', '.').split(' ');\n},\n_itemsChanged: function (change) {\nif (change.path == 'items') {\nif (Array.isArray(this.items)) {\nthis.collection = Polymer.Collection.get(this.items);\n} else if (!this.items) {\nthis.collection = null;\n} else {\nthis._error(this._logf('dom-repeat', 'expected array for `items`,' + ' found', this.items));\n}\nthis._keySplices = [];\nthis._indexSplices = [];\nthis._needFullRefresh = true;\nthis._initializeChunking();\nthis._debounceTemplate(this._render);\n} else if (change.path == 'items.splices') {\nthis._keySplices = this._keySplices.concat(change.value.keySplices);\nthis._indexSplices = this._indexSplices.concat(change.value.indexSplices);\nthis._debounceTemplate(this._render);\n} else {\nvar subpath = change.path.slice(6);\nthis._forwardItemPath(subpath, change.value);\nthis._checkObservedPaths(subpath);\n}\n},\n_checkObservedPaths: function (path) {\nif (this._observePaths) {\npath = path.substring(path.indexOf('.') + 1);\nvar paths = this._observePaths;\nfor (var i = 0; i < paths.length; i++) {\nif (path.indexOf(paths[i]) === 0) {\nthis._needFullRefresh = true;\nif (this.delay) {\nthis.debounce('render', this._render, this.delay);\n} else {\nthis._debounceTemplate(this._render);\n}\nreturn;\n}\n}\n}\n},\nrender: function () {\nthis._needFullRefresh = true;\nthis._debounceTemplate(this._render);\nthis._flushTemplates();\n},\n_render: function () {\nif (this._needFullRefresh) {\nthis._applyFullRefresh();\nthis._needFullRefresh = false;\n} else if (this._keySplices.length) {\nif (this._sortFn) {\nthis._applySplicesUserSort(this._keySplices);\n} else {\nif (this._filterFn) {\nthis._applyFullRefresh();\n} else {\nthis._applySplicesArrayOrder(this._indexSplices);\n}\n}\n} else {\n}\nthis._keySplices = [];\nthis._indexSplices = [];\nvar keyToIdx = this._keyToInstIdx = {};\nfor (var i = this._instances.length - 1; i >= 0; i--) {\nvar inst = this._instances[i];\nif (inst.isPlaceholder && i < this._limit) {\ninst = this._insertInstance(i, inst.__key__);\n} else if (!inst.isPlaceholder && i >= this._limit) {\ninst = this._downgradeInstance(i, inst.__key__);\n}\nkeyToIdx[inst.__key__] = i;\nif (!inst.isPlaceholder) {\ninst.__setProperty(this.indexAs, i, true);\n}\n}\nthis._pool.length = 0;\nthis._setRenderedItemCount(this._instances.length);\nthis.fire('dom-change');\nthis._tryRenderChunk();\n},\n_applyFullRefresh: function () {\nvar c = this.collection;\nvar keys;\nif (this._sortFn) {\nkeys = c ? c.getKeys() : [];\n} else {\nkeys = [];\nvar items = this.items;\nif (items) {\nfor (var i = 0; i < items.length; i++) {\nkeys.push(c.getKey(items[i]));\n}\n}\n}\nvar self = this;\nif (this._filterFn) {\nkeys = keys.filter(function (a) {\nreturn self._filterFn(c.getItem(a));\n});\n}\nif (this._sortFn) {\nkeys.sort(function (a, b) {\nreturn self._sortFn(c.getItem(a), c.getItem(b));\n});\n}\nfor (i = 0; i < keys.length; i++) {\nvar key = keys[i];\nvar inst = this._instances[i];\nif (inst) {\ninst.__key__ = key;\nif (!inst.isPlaceholder && i < this._limit) {\ninst.__setProperty(this.as, c.getItem(key), true);\n}\n} else if (i < this._limit) {\nthis._insertInstance(i, key);\n} else {\nthis._insertPlaceholder(i, key);\n}\n}\nfor (var j = this._instances.length - 1; j >= i; j--) {\nthis._detachAndRemoveInstance(j);\n}\n},\n_numericSort: function (a, b) {\nreturn a - b;\n},\n_applySplicesUserSort: function (splices) {\nvar c = this.collection;\nvar keyMap = {};\nvar key;\nfor (var i = 0, s; i < splices.length && (s = splices[i]); i++) {\nfor (var j = 0; j < s.removed.length; j++) {\nkey = s.removed[j];\nkeyMap[key] = keyMap[key] ? null : -1;\n}\nfor (j = 0; j < s.added.length; j++) {\nkey = s.added[j];\nkeyMap[key] = keyMap[key] ? null : 1;\n}\n}\nvar removedIdxs = [];\nvar addedKeys = [];\nfor (key in keyMap) {\nif (keyMap[key] === -1) {\nremovedIdxs.push(this._keyToInstIdx[key]);\n}\nif (keyMap[key] === 1) {\naddedKeys.push(key);\n}\n}\nif (removedIdxs.length) {\nremovedIdxs.sort(this._numericSort);\nfor (i = removedIdxs.length - 1; i >= 0; i--) {\nvar idx = removedIdxs[i];\nif (idx !== undefined) {\nthis._detachAndRemoveInstance(idx);\n}\n}\n}\nvar self = this;\nif (addedKeys.length) {\nif (this._filterFn) {\naddedKeys = addedKeys.filter(function (a) {\nreturn self._filterFn(c.getItem(a));\n});\n}\naddedKeys.sort(function (a, b) {\nreturn self._sortFn(c.getItem(a), c.getItem(b));\n});\nvar start = 0;\nfor (i = 0; i < addedKeys.length; i++) {\nstart = this._insertRowUserSort(start, addedKeys[i]);\n}\n}\n},\n_insertRowUserSort: function (start, key) {\nvar c = this.collection;\nvar item = c.getItem(key);\nvar end = this._instances.length - 1;\nvar idx = -1;\nwhile (start <= end) {\nvar mid = start + end >> 1;\nvar midKey = this._instances[mid].__key__;\nvar cmp = this._sortFn(c.getItem(midKey), item);\nif (cmp < 0) {\nstart = mid + 1;\n} else if (cmp > 0) {\nend = mid - 1;\n} else {\nidx = mid;\nbreak;\n}\n}\nif (idx < 0) {\nidx = end + 1;\n}\nthis._insertPlaceholder(idx, key);\nreturn idx;\n},\n_applySplicesArrayOrder: function (splices) {\nfor (var i = 0, s; i < splices.length && (s = splices[i]); i++) {\nfor (var j = 0; j < s.removed.length; j++) {\nthis._detachAndRemoveInstance(s.index);\n}\nfor (j = 0; j < s.addedKeys.length; j++) {\nthis._insertPlaceholder(s.index + j, s.addedKeys[j]);\n}\n}\n},\n_detachInstance: function (idx) {\nvar inst = this._instances[idx];\nif (!inst.isPlaceholder) {\nfor (var i = 0; i < inst._children.length; i++) {\nvar el = inst._children[i];\nPolymer.dom(inst.root).appendChild(el);\n}\nreturn inst;\n}\n},\n_attachInstance: function (idx, parent) {\nvar inst = this._instances[idx];\nif (!inst.isPlaceholder) {\nparent.insertBefore(inst.root, this);\n}\n},\n_detachAndRemoveInstance: function (idx) {\nvar inst = this._detachInstance(idx);\nif (inst) {\nthis._pool.push(inst);\n}\nthis._instances.splice(idx, 1);\n},\n_insertPlaceholder: function (idx, key) {\nthis._instances.splice(idx, 0, {\nisPlaceholder: true,\n__key__: key\n});\n},\n_stampInstance: function (idx, key) {\nvar model = { __key__: key };\nmodel[this.as] = this.collection.getItem(key);\nmodel[this.indexAs] = idx;\nreturn this.stamp(model);\n},\n_insertInstance: function (idx, key) {\nvar inst = this._pool.pop();\nif (inst) {\ninst.__setProperty(this.as, this.collection.getItem(key), true);\ninst.__setProperty('__key__', key, true);\n} else {\ninst = this._stampInstance(idx, key);\n}\nvar beforeRow = this._instances[idx + 1];\nvar beforeNode = beforeRow && !beforeRow.isPlaceholder ? beforeRow._children[0] : this;\nvar parentNode = Polymer.dom(this).parentNode;\nPolymer.dom(parentNode).insertBefore(inst.root, beforeNode);\nthis._instances[idx] = inst;\nreturn inst;\n},\n_downgradeInstance: function (idx, key) {\nvar inst = this._detachInstance(idx);\nif (inst) {\nthis._pool.push(inst);\n}\ninst = {\nisPlaceholder: true,\n__key__: key\n};\nthis._instances[idx] = inst;\nreturn inst;\n},\n_showHideChildren: function (hidden) {\nfor (var i = 0; i < this._instances.length; i++) {\nthis._instances[i]._showHideChildren(hidden);\n}\n},\n_forwardInstanceProp: function (inst, prop, value) {\nif (prop == this.as) {\nvar idx;\nif (this._sortFn || this._filterFn) {\nidx = this.items.indexOf(this.collection.getItem(inst.__key__));\n} else {\nidx = inst[this.indexAs];\n}\nthis.set('items.' + idx, value);\n}\n},\n_forwardInstancePath: function (inst, path, value) {\nif (path.indexOf(this.as + '.') === 0) {\nthis._notifyPath('items.' + inst.__key__ + '.' + path.slice(this.as.length + 1), value);\n}\n},\n_forwardParentProp: function (prop, value) {\nvar i$ = this._instances;\nfor (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {\nif (!inst.isPlaceholder) {\ninst.__setProperty(prop, value, true);\n}\n}\n},\n_forwardParentPath: function (path, value) {\nvar i$ = this._instances;\nfor (var i = 0, inst; i < i$.length && (inst = i$[i]); i++) {\nif (!inst.isPlaceholder) {\ninst._notifyPath(path, value, true);\n}\n}\n},\n_forwardItemPath: function (path, value) {\nif (this._keyToInstIdx) {\nvar dot = path.indexOf('.');\nvar key = path.substring(0, dot < 0 ? path.length : dot);\nvar idx = this._keyToInstIdx[key];\nvar inst = this._instances[idx];\nif (inst && !inst.isPlaceholder) {\nif (dot >= 0) {\npath = this.as + '.' + path.substring(dot + 1);\ninst._notifyPath(path, value, true);\n} else {\ninst.__setProperty(this.as, value, true);\n}\n}\n}\n},\nitemForElement: function (el) {\nvar instance = this.modelForElement(el);\nreturn instance && instance[this.as];\n},\nkeyForElement: function (el) {\nvar instance = this.modelForElement(el);\nreturn instance && instance.__key__;\n},\nindexForElement: function (el) {\nvar instance = this.modelForElement(el);\nreturn instance && instance[this.indexAs];\n}\n});Polymer({\nis: 'array-selector',\n_template: null,\nproperties: {\nitems: {\ntype: Array,\nobserver: 'clearSelection'\n},\nmulti: {\ntype: Boolean,\nvalue: false,\nobserver: 'clearSelection'\n},\nselected: {\ntype: Object,\nnotify: true\n},\nselectedItem: {\ntype: Object,\nnotify: true\n},\ntoggle: {\ntype: Boolean,\nvalue: false\n}\n},\nclearSelection: function () {\nif (Array.isArray(this.selected)) {\nfor (var i = 0; i < this.selected.length; i++) {\nthis.unlinkPaths('selected.' + i);\n}\n} else {\nthis.unlinkPaths('selected');\nthis.unlinkPaths('selectedItem');\n}\nif (this.multi) {\nif (!this.selected || this.selected.length) {\nthis.selected = [];\nthis._selectedColl = Polymer.Collection.get(this.selected);\n}\n} else {\nthis.selected = null;\nthis._selectedColl = null;\n}\nthis.selectedItem = null;\n},\nisSelected: function (item) {\nif (this.multi) {\nreturn this._selectedColl.getKey(item) !== undefined;\n} else {\nreturn this.selected == item;\n}\n},\ndeselect: function (item) {\nif (this.multi) {\nif (this.isSelected(item)) {\nvar skey = this._selectedColl.getKey(item);\nthis.arrayDelete('selected', item);\nthis.unlinkPaths('selected.' + skey);\n}\n} else {\nthis.selected = null;\nthis.selectedItem = null;\nthis.unlinkPaths('selected');\nthis.unlinkPaths('selectedItem');\n}\n},\nselect: function (item) {\nvar icol = Polymer.Collection.get(this.items);\nvar key = icol.getKey(item);\nif (this.multi) {\nif (this.isSelected(item)) {\nif (this.toggle) {\nthis.deselect(item);\n}\n} else {\nthis.push('selected', item);\nvar skey = this._selectedColl.getKey(item);\nthis.linkPaths('selected.' + skey, 'items.' + key);\n}\n} else {\nif (this.toggle && item == this.selected) {\nthis.deselect();\n} else {\nthis.selected = item;\nthis.selectedItem = item;\nthis.linkPaths('selected', 'items.' + key);\nthis.linkPaths('selectedItem', 'items.' + key);\n}\n}\n}\n});Polymer({\nis: 'dom-if',\nextends: 'template',\n_template: null,\nproperties: {\n'if': {\ntype: Boolean,\nvalue: false,\nobserver: '_queueRender'\n},\nrestamp: {\ntype: Boolean,\nvalue: false,\nobserver: '_queueRender'\n}\n},\nbehaviors: [Polymer.Templatizer],\n_queueRender: function () {\nthis._debounceTemplate(this._render);\n},\ndetached: function () {\nif (!this.parentNode || this.parentNode.nodeType == Node.DOCUMENT_FRAGMENT_NODE && (!Polymer.Settings.hasShadow || !(this.parentNode instanceof ShadowRoot))) {\nthis._teardownInstance();\n}\n},\nattached: function () {\nif (this.if && this.ctor) {\nthis.async(this._ensureInstance);\n}\n},\nrender: function () {\nthis._flushTemplates();\n},\n_render: function () {\nif (this.if) {\nif (!this.ctor) {\nthis.templatize(this);\n}\nthis._ensureInstance();\nthis._showHideChildren();\n} else if (this.restamp) {\nthis._teardownInstance();\n}\nif (!this.restamp && this._instance) {\nthis._showHideChildren();\n}\nif (this.if != this._lastIf) {\nthis.fire('dom-change');\nthis._lastIf = this.if;\n}\n},\n_ensureInstance: function () {\nvar parentNode = Polymer.dom(this).parentNode;\nif (parentNode) {\nvar parent = Polymer.dom(parentNode);\nif (!this._instance) {\nthis._instance = this.stamp();\nvar root = this._instance.root;\nparent.insertBefore(root, this);\n} else {\nvar c$ = this._instance._children;\nif (c$ && c$.length) {\nvar lastChild = Polymer.dom(this).previousSibling;\nif (lastChild !== c$[c$.length - 1]) {\nfor (var i = 0, n; i < c$.length && (n = c$[i]); i++) {\nparent.insertBefore(n, this);\n}\n}\n}\n}\n}\n},\n_teardownInstance: function () {\nif (this._instance) {\nvar c$ = this._instance._children;\nif (c$ && c$.length) {\nvar parent = Polymer.dom(Polymer.dom(c$[0]).parentNode);\nfor (var i = 0, n; i < c$.length && (n = c$[i]); i++) {\nparent.removeChild(n);\n}\n}\nthis._instance = null;\n}\n},\n_showHideChildren: function () {\nvar hidden = this.__hideTemplateChildren__ || !this.if;\nif (this._instance) {\nthis._instance._showHideChildren(hidden);\n}\n},\n_forwardParentProp: function (prop, value) {\nif (this._instance) {\nthis._instance.__setProperty(prop, value, true);\n}\n},\n_forwardParentPath: function (path, value) {\nif (this._instance) {\nthis._instance._notifyPath(path, value, true);\n}\n}\n});Polymer({\nis: 'dom-bind',\nextends: 'template',\n_template: null,\ncreated: function () {\nvar self = this;\nPolymer.RenderStatus.whenReady(function () {\nif (document.readyState == 'loading') {\ndocument.addEventListener('DOMContentLoaded', function () {\nself._markImportsReady();\n});\n} else {\nself._markImportsReady();\n}\n});\n},\n_ensureReady: function () {\nif (!this._readied) {\nthis._readySelf();\n}\n},\n_markImportsReady: function () {\nthis._importsReady = true;\nthis._ensureReady();\n},\n_registerFeatures: function () {\nthis._prepConstructor();\n},\n_insertChildren: function () {\nvar parentDom = Polymer.dom(Polymer.dom(this).parentNode);\nparentDom.insertBefore(this.root, this);\n},\n_removeChildren: function () {\nif (this._children) {\nfor (var i = 0; i < this._children.length; i++) {\nthis.root.appendChild(this._children[i]);\n}\n}\n},\n_initFeatures: function () {\n},\n_scopeElementClass: function (element, selector) {\nif (this.dataHost) {\nreturn this.dataHost._scopeElementClass(element, selector);\n} else {\nreturn selector;\n}\n},\n_configureInstanceProperties: function () {\n},\n_prepConfigure: function () {\nvar config = {};\nfor (var prop in this._propertyEffects) {\nconfig[prop] = this[prop];\n}\nvar setupConfigure = this._setupConfigure;\nthis._setupConfigure = function () {\nsetupConfigure.call(this, config);\n};\n},\nattached: function () {\nif (this._importsReady) {\nthis.render();\n}\n},\ndetached: function () {\nthis._removeChildren();\n},\nrender: function () {\nthis._ensureReady();\nif (!this._children) {\nthis._template = this;\nthis._prepAnnotations();\nthis._prepEffects();\nthis._prepBehaviors();\nthis._prepConfigure();\nthis._prepBindings();\nthis._prepPropertyInfo();\nPolymer.Base._initFeatures.call(this);\nthis._children = Polymer.TreeApi.arrayCopyChildNodes(this.root);\n}\nthis._insertChildren();\nthis.fire('dom-change');\n}\n});</script>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],"file":"polymer/polymer.html","sourceRoot":"/source/"}