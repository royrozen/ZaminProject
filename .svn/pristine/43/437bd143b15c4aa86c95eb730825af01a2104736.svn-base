{"version":3,"names":[],"mappings":"","sources":["polymer/polymer-mini.html"],"sourcesContent":["<!--\n@license\nCopyright (c) 2014 The Polymer Project Authors. All rights reserved.\nThis code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt\nThe complete set of authors may be found at http://polymer.github.io/AUTHORS.txt\nThe complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt\nCode distributed by Google as part of the polymer project is also\nsubject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt\n--><link rel=\"import\" href=\"polymer-micro.html\">\n\n\n\n<script>Polymer.Base._addFeature({\n_prepTemplate: function () {\nif (this._template === undefined) {\nthis._template = Polymer.DomModule.import(this.is, 'template');\n}\nif (this._template && this._template.hasAttribute('is')) {\nthis._warn(this._logf('_prepTemplate', 'top-level Polymer template ' + 'must not be a type-extension, found', this._template, 'Move inside simple <template>.'));\n}\nif (this._template && !this._template.content && window.HTMLTemplateElement && HTMLTemplateElement.decorate) {\nHTMLTemplateElement.decorate(this._template);\n}\n},\n_stampTemplate: function () {\nif (this._template) {\nthis.root = this.instanceTemplate(this._template);\n}\n},\ninstanceTemplate: function (template) {\nvar dom = document.importNode(template._content || template.content, true);\nreturn dom;\n}\n});(function () {\nvar baseAttachedCallback = Polymer.Base.attachedCallback;\nPolymer.Base._addFeature({\n_hostStack: [],\nready: function () {\n},\n_registerHost: function (host) {\nthis.dataHost = host = host || Polymer.Base._hostStack[Polymer.Base._hostStack.length - 1];\nif (host && host._clients) {\nhost._clients.push(this);\n}\nthis._clients = null;\nthis._clientsReadied = false;\n},\n_beginHosting: function () {\nPolymer.Base._hostStack.push(this);\nif (!this._clients) {\nthis._clients = [];\n}\n},\n_endHosting: function () {\nPolymer.Base._hostStack.pop();\n},\n_tryReady: function () {\nthis._readied = false;\nif (this._canReady()) {\nthis._ready();\n}\n},\n_canReady: function () {\nreturn !this.dataHost || this.dataHost._clientsReadied;\n},\n_ready: function () {\nthis._beforeClientsReady();\nif (this._template) {\nthis._setupRoot();\nthis._readyClients();\n}\nthis._clientsReadied = true;\nthis._clients = null;\nthis._afterClientsReady();\nthis._readySelf();\n},\n_readyClients: function () {\nthis._beginDistribute();\nvar c$ = this._clients;\nif (c$) {\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nc._ready();\n}\n}\nthis._finishDistribute();\n},\n_readySelf: function () {\nthis._doBehavior('ready');\nthis._readied = true;\nif (this._attachedPending) {\nthis._attachedPending = false;\nthis.attachedCallback();\n}\n},\n_beforeClientsReady: function () {\n},\n_afterClientsReady: function () {\n},\n_beforeAttached: function () {\n},\nattachedCallback: function () {\nif (this._readied) {\nthis._beforeAttached();\nbaseAttachedCallback.call(this);\n} else {\nthis._attachedPending = true;\n}\n}\n});\n}());Polymer.ArraySplice = function () {\nfunction newSplice(index, removed, addedCount) {\nreturn {\nindex: index,\nremoved: removed,\naddedCount: addedCount\n};\n}\nvar EDIT_LEAVE = 0;\nvar EDIT_UPDATE = 1;\nvar EDIT_ADD = 2;\nvar EDIT_DELETE = 3;\nfunction ArraySplice() {\n}\nArraySplice.prototype = {\ncalcEditDistances: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {\nvar rowCount = oldEnd - oldStart + 1;\nvar columnCount = currentEnd - currentStart + 1;\nvar distances = new Array(rowCount);\nfor (var i = 0; i < rowCount; i++) {\ndistances[i] = new Array(columnCount);\ndistances[i][0] = i;\n}\nfor (var j = 0; j < columnCount; j++)\ndistances[0][j] = j;\nfor (i = 1; i < rowCount; i++) {\nfor (j = 1; j < columnCount; j++) {\nif (this.equals(current[currentStart + j - 1], old[oldStart + i - 1]))\ndistances[i][j] = distances[i - 1][j - 1];\nelse {\nvar north = distances[i - 1][j] + 1;\nvar west = distances[i][j - 1] + 1;\ndistances[i][j] = north < west ? north : west;\n}\n}\n}\nreturn distances;\n},\nspliceOperationsFromEditDistances: function (distances) {\nvar i = distances.length - 1;\nvar j = distances[0].length - 1;\nvar current = distances[i][j];\nvar edits = [];\nwhile (i > 0 || j > 0) {\nif (i == 0) {\nedits.push(EDIT_ADD);\nj--;\ncontinue;\n}\nif (j == 0) {\nedits.push(EDIT_DELETE);\ni--;\ncontinue;\n}\nvar northWest = distances[i - 1][j - 1];\nvar west = distances[i - 1][j];\nvar north = distances[i][j - 1];\nvar min;\nif (west < north)\nmin = west < northWest ? west : northWest;\nelse\nmin = north < northWest ? north : northWest;\nif (min == northWest) {\nif (northWest == current) {\nedits.push(EDIT_LEAVE);\n} else {\nedits.push(EDIT_UPDATE);\ncurrent = northWest;\n}\ni--;\nj--;\n} else if (min == west) {\nedits.push(EDIT_DELETE);\ni--;\ncurrent = west;\n} else {\nedits.push(EDIT_ADD);\nj--;\ncurrent = north;\n}\n}\nedits.reverse();\nreturn edits;\n},\ncalcSplices: function (current, currentStart, currentEnd, old, oldStart, oldEnd) {\nvar prefixCount = 0;\nvar suffixCount = 0;\nvar minLength = Math.min(currentEnd - currentStart, oldEnd - oldStart);\nif (currentStart == 0 && oldStart == 0)\nprefixCount = this.sharedPrefix(current, old, minLength);\nif (currentEnd == current.length && oldEnd == old.length)\nsuffixCount = this.sharedSuffix(current, old, minLength - prefixCount);\ncurrentStart += prefixCount;\noldStart += prefixCount;\ncurrentEnd -= suffixCount;\noldEnd -= suffixCount;\nif (currentEnd - currentStart == 0 && oldEnd - oldStart == 0)\nreturn [];\nif (currentStart == currentEnd) {\nvar splice = newSplice(currentStart, [], 0);\nwhile (oldStart < oldEnd)\nsplice.removed.push(old[oldStart++]);\nreturn [splice];\n} else if (oldStart == oldEnd)\nreturn [newSplice(currentStart, [], currentEnd - currentStart)];\nvar ops = this.spliceOperationsFromEditDistances(this.calcEditDistances(current, currentStart, currentEnd, old, oldStart, oldEnd));\nsplice = undefined;\nvar splices = [];\nvar index = currentStart;\nvar oldIndex = oldStart;\nfor (var i = 0; i < ops.length; i++) {\nswitch (ops[i]) {\ncase EDIT_LEAVE:\nif (splice) {\nsplices.push(splice);\nsplice = undefined;\n}\nindex++;\noldIndex++;\nbreak;\ncase EDIT_UPDATE:\nif (!splice)\nsplice = newSplice(index, [], 0);\nsplice.addedCount++;\nindex++;\nsplice.removed.push(old[oldIndex]);\noldIndex++;\nbreak;\ncase EDIT_ADD:\nif (!splice)\nsplice = newSplice(index, [], 0);\nsplice.addedCount++;\nindex++;\nbreak;\ncase EDIT_DELETE:\nif (!splice)\nsplice = newSplice(index, [], 0);\nsplice.removed.push(old[oldIndex]);\noldIndex++;\nbreak;\n}\n}\nif (splice) {\nsplices.push(splice);\n}\nreturn splices;\n},\nsharedPrefix: function (current, old, searchLength) {\nfor (var i = 0; i < searchLength; i++)\nif (!this.equals(current[i], old[i]))\nreturn i;\nreturn searchLength;\n},\nsharedSuffix: function (current, old, searchLength) {\nvar index1 = current.length;\nvar index2 = old.length;\nvar count = 0;\nwhile (count < searchLength && this.equals(current[--index1], old[--index2]))\ncount++;\nreturn count;\n},\ncalculateSplices: function (current, previous) {\nreturn this.calcSplices(current, 0, current.length, previous, 0, previous.length);\n},\nequals: function (currentValue, previousValue) {\nreturn currentValue === previousValue;\n}\n};\nreturn new ArraySplice();\n}();Polymer.domInnerHTML = function () {\nvar escapeAttrRegExp = /[&\\u00A0\"]/g;\nvar escapeDataRegExp = /[&\\u00A0<>]/g;\nfunction escapeReplace(c) {\nswitch (c) {\ncase '&':\nreturn '&amp;';\ncase '<':\nreturn '&lt;';\ncase '>':\nreturn '&gt;';\ncase '\"':\nreturn '&quot;';\ncase '\\xA0':\nreturn '&nbsp;';\n}\n}\nfunction escapeAttr(s) {\nreturn s.replace(escapeAttrRegExp, escapeReplace);\n}\nfunction escapeData(s) {\nreturn s.replace(escapeDataRegExp, escapeReplace);\n}\nfunction makeSet(arr) {\nvar set = {};\nfor (var i = 0; i < arr.length; i++) {\nset[arr[i]] = true;\n}\nreturn set;\n}\nvar voidElements = makeSet([\n'area',\n'base',\n'br',\n'col',\n'command',\n'embed',\n'hr',\n'img',\n'input',\n'keygen',\n'link',\n'meta',\n'param',\n'source',\n'track',\n'wbr'\n]);\nvar plaintextParents = makeSet([\n'style',\n'script',\n'xmp',\n'iframe',\n'noembed',\n'noframes',\n'plaintext',\n'noscript'\n]);\nfunction getOuterHTML(node, parentNode, composed) {\nswitch (node.nodeType) {\ncase Node.ELEMENT_NODE:\nvar tagName = node.localName;\nvar s = '<' + tagName;\nvar attrs = node.attributes;\nfor (var i = 0, attr; attr = attrs[i]; i++) {\ns += ' ' + attr.name + '=\"' + escapeAttr(attr.value) + '\"';\n}\ns += '>';\nif (voidElements[tagName]) {\nreturn s;\n}\nreturn s + getInnerHTML(node, composed) + '</' + tagName + '>';\ncase Node.TEXT_NODE:\nvar data = node.data;\nif (parentNode && plaintextParents[parentNode.localName]) {\nreturn data;\n}\nreturn escapeData(data);\ncase Node.COMMENT_NODE:\nreturn '<!--' + node.data + '-->';\ndefault:\nconsole.error(node);\nthrow new Error('not implemented');\n}\n}\nfunction getInnerHTML(node, composed) {\nif (node instanceof HTMLTemplateElement)\nnode = node.content;\nvar s = '';\nvar c$ = Polymer.dom(node).childNodes;\nfor (var i = 0, l = c$.length, child; i < l && (child = c$[i]); i++) {\ns += getOuterHTML(child, node, composed);\n}\nreturn s;\n}\nreturn { getInnerHTML: getInnerHTML };\n}();(function () {\n'use strict';\nvar nativeInsertBefore = Element.prototype.insertBefore;\nvar nativeAppendChild = Element.prototype.appendChild;\nvar nativeRemoveChild = Element.prototype.removeChild;\nPolymer.TreeApi = {\narrayCopyChildNodes: function (parent) {\nvar copy = [], i = 0;\nfor (var n = parent.firstChild; n; n = n.nextSibling) {\ncopy[i++] = n;\n}\nreturn copy;\n},\narrayCopyChildren: function (parent) {\nvar copy = [], i = 0;\nfor (var n = parent.firstElementChild; n; n = n.nextElementSibling) {\ncopy[i++] = n;\n}\nreturn copy;\n},\narrayCopy: function (a$) {\nvar l = a$.length;\nvar copy = new Array(l);\nfor (var i = 0; i < l; i++) {\ncopy[i] = a$[i];\n}\nreturn copy;\n}\n};\nPolymer.TreeApi.Logical = {\nhasParentNode: function (node) {\nreturn Boolean(node.__dom && node.__dom.parentNode);\n},\nhasChildNodes: function (node) {\nreturn Boolean(node.__dom && node.__dom.childNodes !== undefined);\n},\ngetChildNodes: function (node) {\nreturn this.hasChildNodes(node) ? this._getChildNodes(node) : node.childNodes;\n},\n_getChildNodes: function (node) {\nif (!node.__dom.childNodes) {\nnode.__dom.childNodes = [];\nfor (var n = node.__dom.firstChild; n; n = n.__dom.nextSibling) {\nnode.__dom.childNodes.push(n);\n}\n}\nreturn node.__dom.childNodes;\n},\ngetParentNode: function (node) {\nreturn node.__dom && node.__dom.parentNode !== undefined ? node.__dom.parentNode : node.parentNode;\n},\ngetFirstChild: function (node) {\nreturn node.__dom && node.__dom.firstChild !== undefined ? node.__dom.firstChild : node.firstChild;\n},\ngetLastChild: function (node) {\nreturn node.__dom && node.__dom.lastChild !== undefined ? node.__dom.lastChild : node.lastChild;\n},\ngetNextSibling: function (node) {\nreturn node.__dom && node.__dom.nextSibling !== undefined ? node.__dom.nextSibling : node.nextSibling;\n},\ngetPreviousSibling: function (node) {\nreturn node.__dom && node.__dom.previousSibling !== undefined ? node.__dom.previousSibling : node.previousSibling;\n},\ngetFirstElementChild: function (node) {\nreturn node.__dom && node.__dom.firstChild !== undefined ? this._getFirstElementChild(node) : node.firstElementChild;\n},\n_getFirstElementChild: function (node) {\nvar n = node.__dom.firstChild;\nwhile (n && n.nodeType !== Node.ELEMENT_NODE) {\nn = n.__dom.nextSibling;\n}\nreturn n;\n},\ngetLastElementChild: function (node) {\nreturn node.__dom && node.__dom.lastChild !== undefined ? this._getLastElementChild(node) : node.lastElementChild;\n},\n_getLastElementChild: function (node) {\nvar n = node.__dom.lastChild;\nwhile (n && n.nodeType !== Node.ELEMENT_NODE) {\nn = n.__dom.previousSibling;\n}\nreturn n;\n},\ngetNextElementSibling: function (node) {\nreturn node.__dom && node.__dom.nextSibling !== undefined ? this._getNextElementSibling(node) : node.nextElementSibling;\n},\n_getNextElementSibling: function (node) {\nvar n = node.__dom.nextSibling;\nwhile (n && n.nodeType !== Node.ELEMENT_NODE) {\nn = n.__dom.nextSibling;\n}\nreturn n;\n},\ngetPreviousElementSibling: function (node) {\nreturn node.__dom && node.__dom.previousSibling !== undefined ? this._getPreviousElementSibling(node) : node.previousElementSibling;\n},\n_getPreviousElementSibling: function (node) {\nvar n = node.__dom.previousSibling;\nwhile (n && n.nodeType !== Node.ELEMENT_NODE) {\nn = n.__dom.previousSibling;\n}\nreturn n;\n},\nsaveChildNodes: function (node) {\nif (!this.hasChildNodes(node)) {\nnode.__dom = node.__dom || {};\nnode.__dom.firstChild = node.firstChild;\nnode.__dom.lastChild = node.lastChild;\nnode.__dom.childNodes = [];\nfor (var n = node.firstChild; n; n = n.nextSibling) {\nn.__dom = n.__dom || {};\nn.__dom.parentNode = node;\nnode.__dom.childNodes.push(n);\nn.__dom.nextSibling = n.nextSibling;\nn.__dom.previousSibling = n.previousSibling;\n}\n}\n},\nrecordInsertBefore: function (node, container, ref_node) {\ncontainer.__dom.childNodes = null;\nif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\nfor (var n = node.firstChild; n; n = n.nextSibling) {\nthis._linkNode(n, container, ref_node);\n}\n} else {\nthis._linkNode(node, container, ref_node);\n}\n},\n_linkNode: function (node, container, ref_node) {\nnode.__dom = node.__dom || {};\ncontainer.__dom = container.__dom || {};\nif (ref_node) {\nref_node.__dom = ref_node.__dom || {};\n}\nnode.__dom.previousSibling = ref_node ? ref_node.__dom.previousSibling : container.__dom.lastChild;\nif (node.__dom.previousSibling) {\nnode.__dom.previousSibling.__dom.nextSibling = node;\n}\nnode.__dom.nextSibling = ref_node || null;\nif (node.__dom.nextSibling) {\nnode.__dom.nextSibling.__dom.previousSibling = node;\n}\nnode.__dom.parentNode = container;\nif (ref_node) {\nif (ref_node === container.__dom.firstChild) {\ncontainer.__dom.firstChild = node;\n}\n} else {\ncontainer.__dom.lastChild = node;\nif (!container.__dom.firstChild) {\ncontainer.__dom.firstChild = node;\n}\n}\ncontainer.__dom.childNodes = null;\n},\nrecordRemoveChild: function (node, container) {\nnode.__dom = node.__dom || {};\ncontainer.__dom = container.__dom || {};\nif (node === container.__dom.firstChild) {\ncontainer.__dom.firstChild = node.__dom.nextSibling;\n}\nif (node === container.__dom.lastChild) {\ncontainer.__dom.lastChild = node.__dom.previousSibling;\n}\nvar p = node.__dom.previousSibling;\nvar n = node.__dom.nextSibling;\nif (p) {\np.__dom.nextSibling = n;\n}\nif (n) {\nn.__dom.previousSibling = p;\n}\nnode.__dom.parentNode = node.__dom.previousSibling = node.__dom.nextSibling = undefined;\ncontainer.__dom.childNodes = null;\n}\n};\nPolymer.TreeApi.Composed = {\ngetChildNodes: function (node) {\nreturn Polymer.TreeApi.arrayCopyChildNodes(node);\n},\ngetParentNode: function (node) {\nreturn node.parentNode;\n},\nclearChildNodes: function (node) {\nnode.textContent = '';\n},\ninsertBefore: function (parentNode, newChild, refChild) {\nreturn nativeInsertBefore.call(parentNode, newChild, refChild || null);\n},\nappendChild: function (parentNode, newChild) {\nreturn nativeAppendChild.call(parentNode, newChild);\n},\nremoveChild: function (parentNode, node) {\nreturn nativeRemoveChild.call(parentNode, node);\n}\n};\n}());Polymer.DomApi = function () {\n'use strict';\nvar Settings = Polymer.Settings;\nvar TreeApi = Polymer.TreeApi;\nvar DomApi = function (node) {\nthis.node = needsToWrap ? DomApi.wrap(node) : node;\n};\nvar needsToWrap = Settings.hasShadow && !Settings.nativeShadow;\nDomApi.wrap = window.wrap ? window.wrap : function (node) {\nreturn node;\n};\nDomApi.prototype = {\nflush: function () {\nPolymer.dom.flush();\n},\ndeepContains: function (node) {\nif (this.node.contains(node)) {\nreturn true;\n}\nvar n = node;\nvar doc = node.ownerDocument;\nwhile (n && n !== doc && n !== this.node) {\nn = Polymer.dom(n).parentNode || n.host;\n}\nreturn n === this.node;\n},\nqueryDistributedElements: function (selector) {\nvar c$ = this.getEffectiveChildNodes();\nvar list = [];\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nif (c.nodeType === Node.ELEMENT_NODE && DomApi.matchesSelector.call(c, selector)) {\nlist.push(c);\n}\n}\nreturn list;\n},\ngetEffectiveChildNodes: function () {\nvar list = [];\nvar c$ = this.childNodes;\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nif (c.localName === CONTENT) {\nvar d$ = dom(c).getDistributedNodes();\nfor (var j = 0; j < d$.length; j++) {\nlist.push(d$[j]);\n}\n} else {\nlist.push(c);\n}\n}\nreturn list;\n},\nobserveNodes: function (callback) {\nif (callback) {\nif (!this.observer) {\nthis.observer = this.node.localName === CONTENT ? new DomApi.DistributedNodesObserver(this) : new DomApi.EffectiveNodesObserver(this);\n}\nreturn this.observer.addListener(callback);\n}\n},\nunobserveNodes: function (handle) {\nif (this.observer) {\nthis.observer.removeListener(handle);\n}\n},\nnotifyObserver: function () {\nif (this.observer) {\nthis.observer.notify();\n}\n},\n_query: function (matcher, node, halter) {\nnode = node || this.node;\nvar list = [];\nthis._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);\nreturn list;\n},\n_queryElements: function (elements, matcher, halter, list) {\nfor (var i = 0, l = elements.length, c; i < l && (c = elements[i]); i++) {\nif (c.nodeType === Node.ELEMENT_NODE) {\nif (this._queryElement(c, matcher, halter, list)) {\nreturn true;\n}\n}\n}\n},\n_queryElement: function (node, matcher, halter, list) {\nvar result = matcher(node);\nif (result) {\nlist.push(node);\n}\nif (halter && halter(result)) {\nreturn result;\n}\nthis._queryElements(TreeApi.Logical.getChildNodes(node), matcher, halter, list);\n}\n};\nvar CONTENT = DomApi.CONTENT = 'content';\nvar dom = DomApi.factory = function (node) {\nnode = node || document;\nif (!node.__domApi) {\nnode.__domApi = new DomApi.ctor(node);\n}\nreturn node.__domApi;\n};\nDomApi.hasApi = function (node) {\nreturn Boolean(node.__domApi);\n};\nDomApi.ctor = DomApi;\nPolymer.dom = function (obj, patch) {\nif (obj instanceof Event) {\nreturn Polymer.EventApi.factory(obj);\n} else {\nreturn DomApi.factory(obj, patch);\n}\n};\nvar p = Element.prototype;\nDomApi.matchesSelector = p.matches || p.matchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;\nreturn DomApi;\n}();(function () {\n'use strict';\nvar Settings = Polymer.Settings;\nvar DomApi = Polymer.DomApi;\nvar dom = DomApi.factory;\nvar TreeApi = Polymer.TreeApi;\nvar getInnerHTML = Polymer.domInnerHTML.getInnerHTML;\nvar CONTENT = DomApi.CONTENT;\nif (Settings.useShadow) {\nreturn;\n}\nvar nativeCloneNode = Element.prototype.cloneNode;\nvar nativeImportNode = Document.prototype.importNode;\nPolymer.Base.extend(DomApi.prototype, {\n_lazyDistribute: function (host) {\nif (host.shadyRoot && host.shadyRoot._distributionClean) {\nhost.shadyRoot._distributionClean = false;\nPolymer.dom.addDebouncer(host.debounce('_distribute', host._distributeContent));\n}\n},\nappendChild: function (node) {\nreturn this.insertBefore(node);\n},\ninsertBefore: function (node, ref_node) {\nif (ref_node && TreeApi.Logical.getParentNode(ref_node) !== this.node) {\nthrow Error('The ref_node to be inserted before is not a child ' + 'of this node');\n}\nif (node.nodeType !== Node.DOCUMENT_FRAGMENT_NODE) {\nvar parent = TreeApi.Logical.getParentNode(node);\nif (parent) {\nif (DomApi.hasApi(parent)) {\ndom(parent).notifyObserver();\n}\nthis._removeNode(node);\n} else {\nthis._removeOwnerShadyRoot(node);\n}\n}\nif (!this._addNode(node, ref_node)) {\nif (ref_node) {\nref_node = ref_node.localName === CONTENT ? this._firstComposedNode(ref_node) : ref_node;\n}\nvar container = this.node._isShadyRoot ? this.node.host : this.node;\nif (ref_node) {\nTreeApi.Composed.insertBefore(container, node, ref_node);\n} else {\nTreeApi.Composed.appendChild(container, node);\n}\n}\nthis.notifyObserver();\nreturn node;\n},\n_addNode: function (node, ref_node) {\nvar root = this.getOwnerRoot();\nif (root) {\nvar ipAdded = this._maybeAddInsertionPoint(node, this.node);\nif (!root._invalidInsertionPoints) {\nroot._invalidInsertionPoints = ipAdded;\n}\nthis._addNodeToHost(root.host, node);\n}\nif (TreeApi.Logical.hasChildNodes(this.node)) {\nTreeApi.Logical.recordInsertBefore(node, this.node, ref_node);\n}\nvar handled = this._maybeDistribute(node) || this.node.shadyRoot;\nif (handled) {\nif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {\nwhile (node.firstChild) {\nTreeApi.Composed.removeChild(node, node.firstChild);\n}\n} else {\nvar parent = TreeApi.Composed.getParentNode(node);\nif (parent) {\nTreeApi.Composed.removeChild(parent, node);\n}\n}\n}\nreturn handled;\n},\nremoveChild: function (node) {\nif (TreeApi.Logical.getParentNode(node) !== this.node) {\nthrow Error('The node to be removed is not a child of this node: ' + node);\n}\nif (!this._removeNode(node)) {\nvar container = this.node._isShadyRoot ? this.node.host : this.node;\nvar parent = TreeApi.Composed.getParentNode(node);\nif (container === parent) {\nTreeApi.Composed.removeChild(container, node);\n}\n}\nthis.notifyObserver();\nreturn node;\n},\n_removeNode: function (node) {\nvar logicalParent = TreeApi.Logical.hasParentNode(node) && TreeApi.Logical.getParentNode(node);\nvar distributed;\nvar root = this._ownerShadyRootForNode(node);\nif (logicalParent) {\ndistributed = dom(node)._maybeDistributeParent();\nTreeApi.Logical.recordRemoveChild(node, logicalParent);\nif (root && this._removeDistributedChildren(root, node)) {\nroot._invalidInsertionPoints = true;\nthis._lazyDistribute(root.host);\n}\n}\nthis._removeOwnerShadyRoot(node);\nif (root) {\nthis._removeNodeFromHost(root.host, node);\n}\nreturn distributed;\n},\nreplaceChild: function (node, ref_node) {\nthis.insertBefore(node, ref_node);\nthis.removeChild(ref_node);\nreturn node;\n},\n_hasCachedOwnerRoot: function (node) {\nreturn Boolean(node._ownerShadyRoot !== undefined);\n},\ngetOwnerRoot: function () {\nreturn this._ownerShadyRootForNode(this.node);\n},\n_ownerShadyRootForNode: function (node) {\nif (!node) {\nreturn;\n}\nvar root = node._ownerShadyRoot;\nif (root === undefined) {\nif (node._isShadyRoot) {\nroot = node;\n} else {\nvar parent = TreeApi.Logical.getParentNode(node);\nif (parent) {\nroot = parent._isShadyRoot ? parent : this._ownerShadyRootForNode(parent);\n} else {\nroot = null;\n}\n}\nif (root || document.documentElement.contains(node)) {\nnode._ownerShadyRoot = root;\n}\n}\nreturn root;\n},\n_maybeDistribute: function (node) {\nvar fragContent = node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent && dom(node).querySelector(CONTENT);\nvar wrappedContent = fragContent && TreeApi.Logical.getParentNode(fragContent).nodeType !== Node.DOCUMENT_FRAGMENT_NODE;\nvar hasContent = fragContent || node.localName === CONTENT;\nif (hasContent) {\nvar root = this.getOwnerRoot();\nif (root) {\nthis._lazyDistribute(root.host);\n}\n}\nvar needsDist = this._nodeNeedsDistribution(this.node);\nif (needsDist) {\nthis._lazyDistribute(this.node);\n}\nreturn needsDist || hasContent && !wrappedContent;\n},\n_maybeAddInsertionPoint: function (node, parent) {\nvar added;\nif (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE && !node.__noContent) {\nvar c$ = dom(node).querySelectorAll(CONTENT);\nfor (var i = 0, n, np, na; i < c$.length && (n = c$[i]); i++) {\nnp = TreeApi.Logical.getParentNode(n);\nif (np === node) {\nnp = parent;\n}\nna = this._maybeAddInsertionPoint(n, np);\nadded = added || na;\n}\n} else if (node.localName === CONTENT) {\nTreeApi.Logical.saveChildNodes(parent);\nTreeApi.Logical.saveChildNodes(node);\nadded = true;\n}\nreturn added;\n},\n_updateInsertionPoints: function (host) {\nvar i$ = host.shadyRoot._insertionPoints = dom(host.shadyRoot).querySelectorAll(CONTENT);\nfor (var i = 0, c; i < i$.length; i++) {\nc = i$[i];\nTreeApi.Logical.saveChildNodes(c);\nTreeApi.Logical.saveChildNodes(TreeApi.Logical.getParentNode(c));\n}\n},\n_nodeNeedsDistribution: function (node) {\nreturn node && node.shadyRoot && DomApi.hasInsertionPoint(node.shadyRoot);\n},\n_addNodeToHost: function (host, node) {\nif (host._elementAdd) {\nhost._elementAdd(node);\n}\n},\n_removeNodeFromHost: function (host, node) {\nif (host._elementRemove) {\nhost._elementRemove(node);\n}\n},\n_removeDistributedChildren: function (root, container) {\nvar hostNeedsDist;\nvar ip$ = root._insertionPoints;\nfor (var i = 0; i < ip$.length; i++) {\nvar content = ip$[i];\nif (this._contains(container, content)) {\nvar dc$ = dom(content).getDistributedNodes();\nfor (var j = 0; j < dc$.length; j++) {\nhostNeedsDist = true;\nvar node = dc$[j];\nvar parent = TreeApi.Composed.getParentNode(node);\nif (parent) {\nTreeApi.Composed.removeChild(parent, node);\n}\n}\n}\n}\nreturn hostNeedsDist;\n},\n_contains: function (container, node) {\nwhile (node) {\nif (node == container) {\nreturn true;\n}\nnode = TreeApi.Logical.getParentNode(node);\n}\n},\n_removeOwnerShadyRoot: function (node) {\nif (this._hasCachedOwnerRoot(node)) {\nvar c$ = TreeApi.Logical.getChildNodes(node);\nfor (var i = 0, l = c$.length, n; i < l && (n = c$[i]); i++) {\nthis._removeOwnerShadyRoot(n);\n}\n}\nnode._ownerShadyRoot = undefined;\n},\n_firstComposedNode: function (content) {\nvar n$ = dom(content).getDistributedNodes();\nfor (var i = 0, l = n$.length, n, p$; i < l && (n = n$[i]); i++) {\np$ = dom(n).getDestinationInsertionPoints();\nif (p$[p$.length - 1] === content) {\nreturn n;\n}\n}\n},\nquerySelector: function (selector) {\nvar result = this._query(function (n) {\nreturn DomApi.matchesSelector.call(n, selector);\n}, this.node, function (n) {\nreturn Boolean(n);\n})[0];\nreturn result || null;\n},\nquerySelectorAll: function (selector) {\nreturn this._query(function (n) {\nreturn DomApi.matchesSelector.call(n, selector);\n}, this.node);\n},\ngetDestinationInsertionPoints: function () {\nreturn this.node._destinationInsertionPoints || [];\n},\ngetDistributedNodes: function () {\nreturn this.node._distributedNodes || [];\n},\n_clear: function () {\nwhile (this.childNodes.length) {\nthis.removeChild(this.childNodes[0]);\n}\n},\nsetAttribute: function (name, value) {\nthis.node.setAttribute(name, value);\nthis._maybeDistributeParent();\n},\nremoveAttribute: function (name) {\nthis.node.removeAttribute(name);\nthis._maybeDistributeParent();\n},\n_maybeDistributeParent: function () {\nif (this._nodeNeedsDistribution(this.parentNode)) {\nthis._lazyDistribute(this.parentNode);\nreturn true;\n}\n},\ncloneNode: function (deep) {\nvar n = nativeCloneNode.call(this.node, false);\nif (deep) {\nvar c$ = this.childNodes;\nvar d = dom(n);\nfor (var i = 0, nc; i < c$.length; i++) {\nnc = dom(c$[i]).cloneNode(true);\nd.appendChild(nc);\n}\n}\nreturn n;\n},\nimportNode: function (externalNode, deep) {\nvar doc = this.node instanceof Document ? this.node : this.node.ownerDocument;\nvar n = nativeImportNode.call(doc, externalNode, false);\nif (deep) {\nvar c$ = TreeApi.Logical.getChildNodes(externalNode);\nvar d = dom(n);\nfor (var i = 0, nc; i < c$.length; i++) {\nnc = dom(doc).importNode(c$[i], true);\nd.appendChild(nc);\n}\n}\nreturn n;\n},\n_getComposedInnerHTML: function () {\nreturn getInnerHTML(this.node, true);\n}\n});\nObject.defineProperties(DomApi.prototype, {\nactiveElement: {\nget: function () {\nvar active = document.activeElement;\nif (!active) {\nreturn null;\n}\nvar isShadyRoot = !!this.node._isShadyRoot;\nif (this.node !== document) {\nif (!isShadyRoot) {\nreturn null;\n}\nif (this.node.host === active || !this.node.host.contains(active)) {\nreturn null;\n}\n}\nvar activeRoot = dom(active).getOwnerRoot();\nwhile (activeRoot && activeRoot !== this.node) {\nactive = activeRoot.host;\nactiveRoot = dom(active).getOwnerRoot();\n}\nif (this.node === document) {\nreturn activeRoot ? null : active;\n} else {\nreturn activeRoot === this.node ? active : null;\n}\n},\nconfigurable: true\n},\nchildNodes: {\nget: function () {\nvar c$ = TreeApi.Logical.getChildNodes(this.node);\nreturn Array.isArray(c$) ? c$ : TreeApi.arrayCopyChildNodes(this.node);\n},\nconfigurable: true\n},\nchildren: {\nget: function () {\nif (TreeApi.Logical.hasChildNodes(this.node)) {\nreturn Array.prototype.filter.call(this.childNodes, function (n) {\nreturn n.nodeType === Node.ELEMENT_NODE;\n});\n} else {\nreturn TreeApi.arrayCopyChildren(this.node);\n}\n},\nconfigurable: true\n},\nparentNode: {\nget: function () {\nreturn TreeApi.Logical.getParentNode(this.node);\n},\nconfigurable: true\n},\nfirstChild: {\nget: function () {\nreturn TreeApi.Logical.getFirstChild(this.node);\n},\nconfigurable: true\n},\nlastChild: {\nget: function () {\nreturn TreeApi.Logical.getLastChild(this.node);\n},\nconfigurable: true\n},\nnextSibling: {\nget: function () {\nreturn TreeApi.Logical.getNextSibling(this.node);\n},\nconfigurable: true\n},\npreviousSibling: {\nget: function () {\nreturn TreeApi.Logical.getPreviousSibling(this.node);\n},\nconfigurable: true\n},\nfirstElementChild: {\nget: function () {\nreturn TreeApi.Logical.getFirstElementChild(this.node);\n},\nconfigurable: true\n},\nlastElementChild: {\nget: function () {\nreturn TreeApi.Logical.getLastElementChild(this.node);\n},\nconfigurable: true\n},\nnextElementSibling: {\nget: function () {\nreturn TreeApi.Logical.getNextElementSibling(this.node);\n},\nconfigurable: true\n},\npreviousElementSibling: {\nget: function () {\nreturn TreeApi.Logical.getPreviousElementSibling(this.node);\n},\nconfigurable: true\n},\ntextContent: {\nget: function () {\nvar nt = this.node.nodeType;\nif (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {\nreturn this.node.textContent;\n} else {\nvar tc = [];\nfor (var i = 0, cn = this.childNodes, c; c = cn[i]; i++) {\nif (c.nodeType !== Node.COMMENT_NODE) {\ntc.push(c.textContent);\n}\n}\nreturn tc.join('');\n}\n},\nset: function (text) {\nvar nt = this.node.nodeType;\nif (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {\nthis.node.textContent = text;\n} else {\nthis._clear();\nif (text) {\nthis.appendChild(document.createTextNode(text));\n}\n}\n},\nconfigurable: true\n},\ninnerHTML: {\nget: function () {\nvar nt = this.node.nodeType;\nif (nt === Node.TEXT_NODE || nt === Node.COMMENT_NODE) {\nreturn null;\n} else {\nreturn getInnerHTML(this.node);\n}\n},\nset: function (text) {\nvar nt = this.node.nodeType;\nif (nt !== Node.TEXT_NODE || nt !== Node.COMMENT_NODE) {\nthis._clear();\nvar d = document.createElement('div');\nd.innerHTML = text;\nvar c$ = TreeApi.arrayCopyChildNodes(d);\nfor (var i = 0; i < c$.length; i++) {\nthis.appendChild(c$[i]);\n}\n}\n},\nconfigurable: true\n}\n});\nDomApi.hasInsertionPoint = function (root) {\nreturn Boolean(root && root._insertionPoints.length);\n};\n}());(function () {\n'use strict';\nvar Settings = Polymer.Settings;\nvar TreeApi = Polymer.TreeApi;\nvar DomApi = Polymer.DomApi;\nif (!Settings.useShadow) {\nreturn;\n}\nPolymer.Base.extend(DomApi.prototype, {\nquerySelectorAll: function (selector) {\nreturn TreeApi.arrayCopy(this.node.querySelectorAll(selector));\n},\ngetOwnerRoot: function () {\nvar n = this.node;\nwhile (n) {\nif (n.nodeType === Node.DOCUMENT_FRAGMENT_NODE && n.host) {\nreturn n;\n}\nn = n.parentNode;\n}\n},\nimportNode: function (externalNode, deep) {\nvar doc = this.node instanceof Document ? this.node : this.node.ownerDocument;\nreturn doc.importNode(externalNode, deep);\n},\ngetDestinationInsertionPoints: function () {\nvar n$ = this.node.getDestinationInsertionPoints && this.node.getDestinationInsertionPoints();\nreturn n$ ? TreeApi.arrayCopy(n$) : [];\n},\ngetDistributedNodes: function () {\nvar n$ = this.node.getDistributedNodes && this.node.getDistributedNodes();\nreturn n$ ? TreeApi.arrayCopy(n$) : [];\n}\n});\nObject.defineProperties(DomApi.prototype, {\nactiveElement: {\nget: function () {\nvar node = DomApi.wrap(this.node);\nvar activeElement = node.activeElement;\nreturn node.contains(activeElement) ? activeElement : null;\n},\nconfigurable: true\n},\nchildNodes: {\nget: function () {\nreturn TreeApi.arrayCopyChildNodes(this.node);\n},\nconfigurable: true\n},\nchildren: {\nget: function () {\nreturn TreeApi.arrayCopyChildren(this.node);\n},\nconfigurable: true\n},\ntextContent: {\nget: function () {\nreturn this.node.textContent;\n},\nset: function (value) {\nreturn this.node.textContent = value;\n},\nconfigurable: true\n},\ninnerHTML: {\nget: function () {\nreturn this.node.innerHTML;\n},\nset: function (value) {\nreturn this.node.innerHTML = value;\n},\nconfigurable: true\n}\n});\nvar forwardMethods = function (m$) {\nfor (var i = 0; i < m$.length; i++) {\nforwardMethod(m$[i]);\n}\n};\nvar forwardMethod = function (method) {\nDomApi.prototype[method] = function () {\nreturn this.node[method].apply(this.node, arguments);\n};\n};\nforwardMethods([\n'cloneNode',\n'appendChild',\n'insertBefore',\n'removeChild',\n'replaceChild',\n'setAttribute',\n'removeAttribute',\n'querySelector'\n]);\nvar forwardProperties = function (f$) {\nfor (var i = 0; i < f$.length; i++) {\nforwardProperty(f$[i]);\n}\n};\nvar forwardProperty = function (name) {\nObject.defineProperty(DomApi.prototype, name, {\nget: function () {\nreturn this.node[name];\n},\nconfigurable: true\n});\n};\nforwardProperties([\n'parentNode',\n'firstChild',\n'lastChild',\n'nextSibling',\n'previousSibling',\n'firstElementChild',\n'lastElementChild',\n'nextElementSibling',\n'previousElementSibling'\n]);\n}());Polymer.Base.extend(Polymer.dom, {\n_flushGuard: 0,\n_FLUSH_MAX: 100,\n_needsTakeRecords: !Polymer.Settings.useNativeCustomElements,\n_debouncers: [],\n_staticFlushList: [],\n_finishDebouncer: null,\nflush: function () {\nthis._flushGuard = 0;\nthis._prepareFlush();\nwhile (this._debouncers.length && this._flushGuard < this._FLUSH_MAX) {\nwhile (this._debouncers.length) {\nthis._debouncers.shift().complete();\n}\nif (this._finishDebouncer) {\nthis._finishDebouncer.complete();\n}\nthis._prepareFlush();\nthis._flushGuard++;\n}\nif (this._flushGuard >= this._FLUSH_MAX) {\nconsole.warn('Polymer.dom.flush aborted. Flush may not be complete.');\n}\n},\n_prepareFlush: function () {\nif (this._needsTakeRecords) {\nCustomElements.takeRecords();\n}\nfor (var i = 0; i < this._staticFlushList.length; i++) {\nthis._staticFlushList[i]();\n}\n},\naddStaticFlush: function (fn) {\nthis._staticFlushList.push(fn);\n},\nremoveStaticFlush: function (fn) {\nvar i = this._staticFlushList.indexOf(fn);\nif (i >= 0) {\nthis._staticFlushList.splice(i, 1);\n}\n},\naddDebouncer: function (debouncer) {\nthis._debouncers.push(debouncer);\nthis._finishDebouncer = Polymer.Debounce(this._finishDebouncer, this._finishFlush);\n},\n_finishFlush: function () {\nPolymer.dom._debouncers = [];\n}\n});Polymer.EventApi = function () {\n'use strict';\nvar DomApi = Polymer.DomApi.ctor;\nvar Settings = Polymer.Settings;\nDomApi.Event = function (event) {\nthis.event = event;\n};\nif (Settings.useShadow) {\nDomApi.Event.prototype = {\nget rootTarget() {\nreturn this.event.path[0];\n},\nget localTarget() {\nreturn this.event.target;\n},\nget path() {\nvar path = this.event.path;\nif (!Array.isArray(path)) {\npath = Array.prototype.slice.call(path);\n}\nreturn path;\n}\n};\n} else {\nDomApi.Event.prototype = {\nget rootTarget() {\nreturn this.event.target;\n},\nget localTarget() {\nvar current = this.event.currentTarget;\nvar currentRoot = current && Polymer.dom(current).getOwnerRoot();\nvar p$ = this.path;\nfor (var i = 0; i < p$.length; i++) {\nif (Polymer.dom(p$[i]).getOwnerRoot() === currentRoot) {\nreturn p$[i];\n}\n}\n},\nget path() {\nif (!this.event._path) {\nvar path = [];\nvar current = this.rootTarget;\nwhile (current) {\npath.push(current);\nvar insertionPoints = Polymer.dom(current).getDestinationInsertionPoints();\nif (insertionPoints.length) {\nfor (var i = 0; i < insertionPoints.length - 1; i++) {\npath.push(insertionPoints[i]);\n}\ncurrent = insertionPoints[insertionPoints.length - 1];\n} else {\ncurrent = Polymer.dom(current).parentNode || current.host;\n}\n}\npath.push(window);\nthis.event._path = path;\n}\nreturn this.event._path;\n}\n};\n}\nvar factory = function (event) {\nif (!event.__eventApi) {\nevent.__eventApi = new DomApi.Event(event);\n}\nreturn event.__eventApi;\n};\nreturn { factory: factory };\n}();(function () {\n'use strict';\nvar DomApi = Polymer.DomApi.ctor;\nvar useShadow = Polymer.Settings.useShadow;\nObject.defineProperty(DomApi.prototype, 'classList', {\nget: function () {\nif (!this._classList) {\nthis._classList = new DomApi.ClassList(this);\n}\nreturn this._classList;\n},\nconfigurable: true\n});\nDomApi.ClassList = function (host) {\nthis.domApi = host;\nthis.node = host.node;\n};\nDomApi.ClassList.prototype = {\nadd: function () {\nthis.node.classList.add.apply(this.node.classList, arguments);\nthis._distributeParent();\n},\nremove: function () {\nthis.node.classList.remove.apply(this.node.classList, arguments);\nthis._distributeParent();\n},\ntoggle: function () {\nthis.node.classList.toggle.apply(this.node.classList, arguments);\nthis._distributeParent();\n},\n_distributeParent: function () {\nif (!useShadow) {\nthis.domApi._maybeDistributeParent();\n}\n},\ncontains: function () {\nreturn this.node.classList.contains.apply(this.node.classList, arguments);\n}\n};\n}());(function () {\n'use strict';\nvar DomApi = Polymer.DomApi.ctor;\nvar Settings = Polymer.Settings;\nDomApi.EffectiveNodesObserver = function (domApi) {\nthis.domApi = domApi;\nthis.node = this.domApi.node;\nthis._listeners = [];\n};\nDomApi.EffectiveNodesObserver.prototype = {\naddListener: function (callback) {\nif (!this._isSetup) {\nthis._setup();\nthis._isSetup = true;\n}\nvar listener = {\nfn: callback,\n_nodes: []\n};\nthis._listeners.push(listener);\nthis._scheduleNotify();\nreturn listener;\n},\nremoveListener: function (handle) {\nvar i = this._listeners.indexOf(handle);\nif (i >= 0) {\nthis._listeners.splice(i, 1);\nhandle._nodes = [];\n}\nif (!this._hasListeners()) {\nthis._cleanup();\nthis._isSetup = false;\n}\n},\n_setup: function () {\nthis._observeContentElements(this.domApi.childNodes);\n},\n_cleanup: function () {\nthis._unobserveContentElements(this.domApi.childNodes);\n},\n_hasListeners: function () {\nreturn Boolean(this._listeners.length);\n},\n_scheduleNotify: function () {\nif (this._debouncer) {\nthis._debouncer.stop();\n}\nthis._debouncer = Polymer.Debounce(this._debouncer, this._notify);\nthis._debouncer.context = this;\nPolymer.dom.addDebouncer(this._debouncer);\n},\nnotify: function () {\nif (this._hasListeners()) {\nthis._scheduleNotify();\n}\n},\n_notify: function () {\nthis._beforeCallListeners();\nthis._callListeners();\n},\n_beforeCallListeners: function () {\nthis._updateContentElements();\n},\n_updateContentElements: function () {\nthis._observeContentElements(this.domApi.childNodes);\n},\n_observeContentElements: function (elements) {\nfor (var i = 0, n; i < elements.length && (n = elements[i]); i++) {\nif (this._isContent(n)) {\nn.__observeNodesMap = n.__observeNodesMap || new WeakMap();\nif (!n.__observeNodesMap.has(this)) {\nn.__observeNodesMap.set(this, this._observeContent(n));\n}\n}\n}\n},\n_observeContent: function (content) {\nvar self = this;\nvar h = Polymer.dom(content).observeNodes(function () {\nself._scheduleNotify();\n});\nh._avoidChangeCalculation = true;\nreturn h;\n},\n_unobserveContentElements: function (elements) {\nfor (var i = 0, n, h; i < elements.length && (n = elements[i]); i++) {\nif (this._isContent(n)) {\nh = n.__observeNodesMap.get(this);\nif (h) {\nPolymer.dom(n).unobserveNodes(h);\nn.__observeNodesMap.delete(this);\n}\n}\n}\n},\n_isContent: function (node) {\nreturn node.localName === 'content';\n},\n_callListeners: function () {\nvar o$ = this._listeners;\nvar nodes = this._getEffectiveNodes();\nfor (var i = 0, o; i < o$.length && (o = o$[i]); i++) {\nvar info = this._generateListenerInfo(o, nodes);\nif (info || o._alwaysNotify) {\nthis._callListener(o, info);\n}\n}\n},\n_getEffectiveNodes: function () {\nreturn this.domApi.getEffectiveChildNodes();\n},\n_generateListenerInfo: function (listener, newNodes) {\nif (listener._avoidChangeCalculation) {\nreturn true;\n}\nvar oldNodes = listener._nodes;\nvar info = {\ntarget: this.node,\naddedNodes: [],\nremovedNodes: []\n};\nvar splices = Polymer.ArraySplice.calculateSplices(newNodes, oldNodes);\nfor (var i = 0, s; i < splices.length && (s = splices[i]); i++) {\nfor (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\ninfo.removedNodes.push(n);\n}\n}\nfor (i = 0, s; i < splices.length && (s = splices[i]); i++) {\nfor (j = s.index; j < s.index + s.addedCount; j++) {\ninfo.addedNodes.push(newNodes[j]);\n}\n}\nlistener._nodes = newNodes;\nif (info.addedNodes.length || info.removedNodes.length) {\nreturn info;\n}\n},\n_callListener: function (listener, info) {\nreturn listener.fn.call(this.node, info);\n},\nenableShadowAttributeTracking: function () {\n}\n};\nif (Settings.useShadow) {\nvar baseSetup = DomApi.EffectiveNodesObserver.prototype._setup;\nvar baseCleanup = DomApi.EffectiveNodesObserver.prototype._cleanup;\nPolymer.Base.extend(DomApi.EffectiveNodesObserver.prototype, {\n_setup: function () {\nif (!this._observer) {\nvar self = this;\nthis._mutationHandler = function (mxns) {\nif (mxns && mxns.length) {\nself._scheduleNotify();\n}\n};\nthis._observer = new MutationObserver(this._mutationHandler);\nthis._boundFlush = function () {\nself._flush();\n};\nPolymer.dom.addStaticFlush(this._boundFlush);\nthis._observer.observe(this.node, { childList: true });\n}\nbaseSetup.call(this);\n},\n_cleanup: function () {\nthis._observer.disconnect();\nthis._observer = null;\nthis._mutationHandler = null;\nPolymer.dom.removeStaticFlush(this._boundFlush);\nbaseCleanup.call(this);\n},\n_flush: function () {\nif (this._observer) {\nthis._mutationHandler(this._observer.takeRecords());\n}\n},\nenableShadowAttributeTracking: function () {\nif (this._observer) {\nthis._makeContentListenersAlwaysNotify();\nthis._observer.disconnect();\nthis._observer.observe(this.node, {\nchildList: true,\nattributes: true,\nsubtree: true\n});\nvar root = this.domApi.getOwnerRoot();\nvar host = root && root.host;\nif (host && Polymer.dom(host).observer) {\nPolymer.dom(host).observer.enableShadowAttributeTracking();\n}\n}\n},\n_makeContentListenersAlwaysNotify: function () {\nfor (var i = 0, h; i < this._listeners.length; i++) {\nh = this._listeners[i];\nh._alwaysNotify = h._isContentListener;\n}\n}\n});\n}\n}());(function () {\n'use strict';\nvar DomApi = Polymer.DomApi.ctor;\nvar Settings = Polymer.Settings;\nDomApi.DistributedNodesObserver = function (domApi) {\nDomApi.EffectiveNodesObserver.call(this, domApi);\n};\nDomApi.DistributedNodesObserver.prototype = Object.create(DomApi.EffectiveNodesObserver.prototype);\nPolymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {\n_setup: function () {\n},\n_cleanup: function () {\n},\n_beforeCallListeners: function () {\n},\n_getEffectiveNodes: function () {\nreturn this.domApi.getDistributedNodes();\n}\n});\nif (Settings.useShadow) {\nPolymer.Base.extend(DomApi.DistributedNodesObserver.prototype, {\n_setup: function () {\nif (!this._observer) {\nvar root = this.domApi.getOwnerRoot();\nvar host = root && root.host;\nif (host) {\nvar self = this;\nthis._observer = Polymer.dom(host).observeNodes(function () {\nself._scheduleNotify();\n});\nthis._observer._isContentListener = true;\nif (this._hasAttrSelect()) {\nPolymer.dom(host).observer.enableShadowAttributeTracking();\n}\n}\n}\n},\n_hasAttrSelect: function () {\nvar select = this.node.getAttribute('select');\nreturn select && select.match(/[[.]+/);\n},\n_cleanup: function () {\nvar root = this.domApi.getOwnerRoot();\nvar host = root && root.host;\nif (host) {\nPolymer.dom(host).unobserveNodes(this._observer);\n}\nthis._observer = null;\n}\n});\n}\n}());(function () {\nvar DomApi = Polymer.DomApi;\nvar TreeApi = Polymer.TreeApi;\nPolymer.Base._addFeature({\n_prepShady: function () {\nthis._useContent = this._useContent || Boolean(this._template);\n},\n_setupShady: function () {\nthis.shadyRoot = null;\nif (!this.__domApi) {\nthis.__domApi = null;\n}\nif (!this.__dom) {\nthis.__dom = null;\n}\nif (!this._ownerShadyRoot) {\nthis._ownerShadyRoot = undefined;\n}\n},\n_poolContent: function () {\nif (this._useContent) {\nTreeApi.Logical.saveChildNodes(this);\n}\n},\n_setupRoot: function () {\nif (this._useContent) {\nthis._createLocalRoot();\nif (!this.dataHost) {\nupgradeLogicalChildren(TreeApi.Logical.getChildNodes(this));\n}\n}\n},\n_createLocalRoot: function () {\nthis.shadyRoot = this.root;\nthis.shadyRoot._distributionClean = false;\nthis.shadyRoot._hasDistributed = false;\nthis.shadyRoot._isShadyRoot = true;\nthis.shadyRoot._dirtyRoots = [];\nvar i$ = this.shadyRoot._insertionPoints = !this._notes || this._notes._hasContent ? this.shadyRoot.querySelectorAll('content') : [];\nTreeApi.Logical.saveChildNodes(this.shadyRoot);\nfor (var i = 0, c; i < i$.length; i++) {\nc = i$[i];\nTreeApi.Logical.saveChildNodes(c);\nTreeApi.Logical.saveChildNodes(c.parentNode);\n}\nthis.shadyRoot.host = this;\n},\nget domHost() {\nvar root = Polymer.dom(this).getOwnerRoot();\nreturn root && root.host;\n},\ndistributeContent: function (updateInsertionPoints) {\nif (this.shadyRoot) {\nthis.shadyRoot._invalidInsertionPoints = this.shadyRoot._invalidInsertionPoints || updateInsertionPoints;\nvar host = getTopDistributingHost(this);\nPolymer.dom(this)._lazyDistribute(host);\n}\n},\n_distributeContent: function () {\nif (this._useContent && !this.shadyRoot._distributionClean) {\nif (this.shadyRoot._invalidInsertionPoints) {\nPolymer.dom(this)._updateInsertionPoints(this);\nthis.shadyRoot._invalidInsertionPoints = false;\n}\nthis._beginDistribute();\nthis._distributeDirtyRoots();\nthis._finishDistribute();\n}\n},\n_beginDistribute: function () {\nif (this._useContent && DomApi.hasInsertionPoint(this.shadyRoot)) {\nthis._resetDistribution();\nthis._distributePool(this.shadyRoot, this._collectPool());\n}\n},\n_distributeDirtyRoots: function () {\nvar c$ = this.shadyRoot._dirtyRoots;\nfor (var i = 0, l = c$.length, c; i < l && (c = c$[i]); i++) {\nc._distributeContent();\n}\nthis.shadyRoot._dirtyRoots = [];\n},\n_finishDistribute: function () {\nif (this._useContent) {\nthis.shadyRoot._distributionClean = true;\nif (DomApi.hasInsertionPoint(this.shadyRoot)) {\nthis._composeTree();\nnotifyContentObservers(this.shadyRoot);\n} else {\nif (!this.shadyRoot._hasDistributed) {\nTreeApi.Composed.clearChildNodes(this);\nthis.appendChild(this.shadyRoot);\n} else {\nvar children = this._composeNode(this);\nthis._updateChildNodes(this, children);\n}\n}\nif (!this.shadyRoot._hasDistributed) {\nnotifyInitialDistribution(this);\n}\nthis.shadyRoot._hasDistributed = true;\n}\n},\nelementMatches: function (selector, node) {\nnode = node || this;\nreturn DomApi.matchesSelector.call(node, selector);\n},\n_resetDistribution: function () {\nvar children = TreeApi.Logical.getChildNodes(this);\nfor (var i = 0; i < children.length; i++) {\nvar child = children[i];\nif (child._destinationInsertionPoints) {\nchild._destinationInsertionPoints = undefined;\n}\nif (isInsertionPoint(child)) {\nclearDistributedDestinationInsertionPoints(child);\n}\n}\nvar root = this.shadyRoot;\nvar p$ = root._insertionPoints;\nfor (var j = 0; j < p$.length; j++) {\np$[j]._distributedNodes = [];\n}\n},\n_collectPool: function () {\nvar pool = [];\nvar children = TreeApi.Logical.getChildNodes(this);\nfor (var i = 0; i < children.length; i++) {\nvar child = children[i];\nif (isInsertionPoint(child)) {\npool.push.apply(pool, child._distributedNodes);\n} else {\npool.push(child);\n}\n}\nreturn pool;\n},\n_distributePool: function (node, pool) {\nvar p$ = node._insertionPoints;\nfor (var i = 0, l = p$.length, p; i < l && (p = p$[i]); i++) {\nthis._distributeInsertionPoint(p, pool);\nmaybeRedistributeParent(p, this);\n}\n},\n_distributeInsertionPoint: function (content, pool) {\nvar anyDistributed = false;\nfor (var i = 0, l = pool.length, node; i < l; i++) {\nnode = pool[i];\nif (!node) {\ncontinue;\n}\nif (this._matchesContentSelect(node, content)) {\ndistributeNodeInto(node, content);\npool[i] = undefined;\nanyDistributed = true;\n}\n}\nif (!anyDistributed) {\nvar children = TreeApi.Logical.getChildNodes(content);\nfor (var j = 0; j < children.length; j++) {\ndistributeNodeInto(children[j], content);\n}\n}\n},\n_composeTree: function () {\nthis._updateChildNodes(this, this._composeNode(this));\nvar p$ = this.shadyRoot._insertionPoints;\nfor (var i = 0, l = p$.length, p, parent; i < l && (p = p$[i]); i++) {\nparent = TreeApi.Logical.getParentNode(p);\nif (!parent._useContent && parent !== this && parent !== this.shadyRoot) {\nthis._updateChildNodes(parent, this._composeNode(parent));\n}\n}\n},\n_composeNode: function (node) {\nvar children = [];\nvar c$ = TreeApi.Logical.getChildNodes(node.shadyRoot || node);\nfor (var i = 0; i < c$.length; i++) {\nvar child = c$[i];\nif (isInsertionPoint(child)) {\nvar distributedNodes = child._distributedNodes;\nfor (var j = 0; j < distributedNodes.length; j++) {\nvar distributedNode = distributedNodes[j];\nif (isFinalDestination(child, distributedNode)) {\nchildren.push(distributedNode);\n}\n}\n} else {\nchildren.push(child);\n}\n}\nreturn children;\n},\n_updateChildNodes: function (container, children) {\nvar composed = TreeApi.Composed.getChildNodes(container);\nvar splices = Polymer.ArraySplice.calculateSplices(children, composed);\nfor (var i = 0, d = 0, s; i < splices.length && (s = splices[i]); i++) {\nfor (var j = 0, n; j < s.removed.length && (n = s.removed[j]); j++) {\nif (TreeApi.Composed.getParentNode(n) === container) {\nTreeApi.Composed.removeChild(container, n);\n}\ncomposed.splice(s.index + d, 1);\n}\nd -= s.addedCount;\n}\nfor (var i = 0, s, next; i < splices.length && (s = splices[i]); i++) {\nnext = composed[s.index];\nfor (j = s.index, n; j < s.index + s.addedCount; j++) {\nn = children[j];\nTreeApi.Composed.insertBefore(container, n, next);\ncomposed.splice(j, 0, n);\n}\n}\n},\n_matchesContentSelect: function (node, contentElement) {\nvar select = contentElement.getAttribute('select');\nif (!select) {\nreturn true;\n}\nselect = select.trim();\nif (!select) {\nreturn true;\n}\nif (!(node instanceof Element)) {\nreturn false;\n}\nvar validSelectors = /^(:not\\()?[*.#[a-zA-Z_|]/;\nif (!validSelectors.test(select)) {\nreturn false;\n}\nreturn this.elementMatches(select, node);\n},\n_elementAdd: function () {\n},\n_elementRemove: function () {\n}\n});\nfunction distributeNodeInto(child, insertionPoint) {\ninsertionPoint._distributedNodes.push(child);\nvar points = child._destinationInsertionPoints;\nif (!points) {\nchild._destinationInsertionPoints = [insertionPoint];\n} else {\npoints.push(insertionPoint);\n}\n}\nfunction clearDistributedDestinationInsertionPoints(content) {\nvar e$ = content._distributedNodes;\nif (e$) {\nfor (var i = 0; i < e$.length; i++) {\nvar d = e$[i]._destinationInsertionPoints;\nif (d) {\nd.splice(d.indexOf(content) + 1, d.length);\n}\n}\n}\n}\nfunction maybeRedistributeParent(content, host) {\nvar parent = TreeApi.Logical.getParentNode(content);\nif (parent && parent.shadyRoot && DomApi.hasInsertionPoint(parent.shadyRoot) && parent.shadyRoot._distributionClean) {\nparent.shadyRoot._distributionClean = false;\nhost.shadyRoot._dirtyRoots.push(parent);\n}\n}\nfunction isFinalDestination(insertionPoint, node) {\nvar points = node._destinationInsertionPoints;\nreturn points && points[points.length - 1] === insertionPoint;\n}\nfunction isInsertionPoint(node) {\nreturn node.localName == 'content';\n}\nfunction getTopDistributingHost(host) {\nwhile (host && hostNeedsRedistribution(host)) {\nhost = host.domHost;\n}\nreturn host;\n}\nfunction hostNeedsRedistribution(host) {\nvar c$ = TreeApi.Logical.getChildNodes(host);\nfor (var i = 0, c; i < c$.length; i++) {\nc = c$[i];\nif (c.localName && c.localName === 'content') {\nreturn host.domHost;\n}\n}\n}\nfunction notifyContentObservers(root) {\nfor (var i = 0, c; i < root._insertionPoints.length; i++) {\nc = root._insertionPoints[i];\nif (DomApi.hasApi(c)) {\nPolymer.dom(c).notifyObserver();\n}\n}\n}\nfunction notifyInitialDistribution(host) {\nif (DomApi.hasApi(host)) {\nPolymer.dom(host).notifyObserver();\n}\n}\nvar needsUpgrade = window.CustomElements && !CustomElements.useNative;\nfunction upgradeLogicalChildren(children) {\nif (needsUpgrade && children) {\nfor (var i = 0; i < children.length; i++) {\nCustomElements.upgrade(children[i]);\n}\n}\n}\n}());if (Polymer.Settings.useShadow) {\nPolymer.Base._addFeature({\n_poolContent: function () {\n},\n_beginDistribute: function () {\n},\ndistributeContent: function () {\n},\n_distributeContent: function () {\n},\n_finishDistribute: function () {\n},\n_createLocalRoot: function () {\nthis.createShadowRoot();\nthis.shadowRoot.appendChild(this.root);\nthis.root = this.shadowRoot;\n}\n});\n}Polymer.Async = {\n_currVal: 0,\n_lastVal: 0,\n_callbacks: [],\n_twiddleContent: 0,\n_twiddle: document.createTextNode(''),\nrun: function (callback, waitTime) {\nif (waitTime > 0) {\nreturn ~setTimeout(callback, waitTime);\n} else {\nthis._twiddle.textContent = this._twiddleContent++;\nthis._callbacks.push(callback);\nreturn this._currVal++;\n}\n},\ncancel: function (handle) {\nif (handle < 0) {\nclearTimeout(~handle);\n} else {\nvar idx = handle - this._lastVal;\nif (idx >= 0) {\nif (!this._callbacks[idx]) {\nthrow 'invalid async handle: ' + handle;\n}\nthis._callbacks[idx] = null;\n}\n}\n},\n_atEndOfMicrotask: function () {\nvar len = this._callbacks.length;\nfor (var i = 0; i < len; i++) {\nvar cb = this._callbacks[i];\nif (cb) {\ntry {\ncb();\n} catch (e) {\ni++;\nthis._callbacks.splice(0, i);\nthis._lastVal += i;\nthis._twiddle.textContent = this._twiddleContent++;\nthrow e;\n}\n}\n}\nthis._callbacks.splice(0, len);\nthis._lastVal += len;\n}\n};\nnew window.MutationObserver(function () {\nPolymer.Async._atEndOfMicrotask();\n}).observe(Polymer.Async._twiddle, { characterData: true });Polymer.Debounce = function () {\nvar Async = Polymer.Async;\nvar Debouncer = function (context) {\nthis.context = context;\nvar self = this;\nthis.boundComplete = function () {\nself.complete();\n};\n};\nDebouncer.prototype = {\ngo: function (callback, wait) {\nvar h;\nthis.finish = function () {\nAsync.cancel(h);\n};\nh = Async.run(this.boundComplete, wait);\nthis.callback = callback;\n},\nstop: function () {\nif (this.finish) {\nthis.finish();\nthis.finish = null;\nthis.callback = null;\n}\n},\ncomplete: function () {\nif (this.finish) {\nvar callback = this.callback;\nthis.stop();\ncallback.call(this.context);\n}\n}\n};\nfunction debounce(debouncer, callback, wait) {\nif (debouncer) {\ndebouncer.stop();\n} else {\ndebouncer = new Debouncer(this);\n}\ndebouncer.go(callback, wait);\nreturn debouncer;\n}\nreturn debounce;\n}();Polymer.Base._addFeature({\n_setupDebouncers: function () {\nthis._debouncers = {};\n},\ndebounce: function (jobName, callback, wait) {\nreturn this._debouncers[jobName] = Polymer.Debounce.call(this, this._debouncers[jobName], callback, wait);\n},\nisDebouncerActive: function (jobName) {\nvar debouncer = this._debouncers[jobName];\nreturn !!(debouncer && debouncer.finish);\n},\nflushDebouncer: function (jobName) {\nvar debouncer = this._debouncers[jobName];\nif (debouncer) {\ndebouncer.complete();\n}\n},\ncancelDebouncer: function (jobName) {\nvar debouncer = this._debouncers[jobName];\nif (debouncer) {\ndebouncer.stop();\n}\n}\n});Polymer.DomModule = document.createElement('dom-module');\nPolymer.Base._addFeature({\n_registerFeatures: function () {\nthis._prepIs();\nthis._prepBehaviors();\nthis._prepConstructor();\nthis._prepTemplate();\nthis._prepShady();\nthis._prepPropertyInfo();\n},\n_prepBehavior: function (b) {\nthis._addHostAttributes(b.hostAttributes);\n},\n_initFeatures: function () {\nthis._registerHost();\nif (this._template) {\nthis._poolContent();\nthis._beginHosting();\nthis._stampTemplate();\nthis._endHosting();\n}\nthis._marshalHostAttributes();\nthis._setupDebouncers();\nthis._marshalBehaviors();\nthis._tryReady();\n},\n_marshalBehavior: function (b) {\n}\n});</script>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"],"file":"polymer/polymer-mini.html","sourceRoot":"/source/"}